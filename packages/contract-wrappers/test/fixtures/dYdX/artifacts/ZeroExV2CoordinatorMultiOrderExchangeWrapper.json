{
    "schemaVersion": "2.0.0",
    "contractName": "ZeroExV2CoordinatorMultiOrderExchangeWrapper",
    "compilerOutput": {
        "abi": [
            {
                "constant": true,
                "inputs": [
                    {
                        "name": "",
                        "type": "bytes32"
                    },
                    {
                        "name": "",
                        "type": "bytes"
                    }
                ],
                "name": "isValidSignature",
                "outputs": [
                    {
                        "name": "",
                        "type": "bytes4"
                    }
                ],
                "payable": false,
                "stateMutability": "pure",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [
                    {
                        "components": [
                            {
                                "name": "salt",
                                "type": "uint256"
                            },
                            {
                                "name": "signerAddress",
                                "type": "address"
                            },
                            {
                                "name": "data",
                                "type": "bytes"
                            }
                        ],
                        "name": "transaction",
                        "type": "tuple"
                    }
                ],
                "name": "getTransactionHash",
                "outputs": [
                    {
                        "name": "transactionHash",
                        "type": "bytes32"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [
                    {
                        "name": "makerToken",
                        "type": "address"
                    },
                    {
                        "name": "takerToken",
                        "type": "address"
                    },
                    {
                        "name": "desiredMakerToken",
                        "type": "uint256"
                    },
                    {
                        "name": "orderData",
                        "type": "bytes"
                    }
                ],
                "name": "getExchangeCost",
                "outputs": [
                    {
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "ZERO_EX_EXCHANGE",
                "outputs": [
                    {
                        "name": "",
                        "type": "address"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {
                        "name": "",
                        "type": "address"
                    },
                    {
                        "name": "receiver",
                        "type": "address"
                    },
                    {
                        "name": "makerToken",
                        "type": "address"
                    },
                    {
                        "name": "takerToken",
                        "type": "address"
                    },
                    {
                        "name": "requestedFillAmount",
                        "type": "uint256"
                    },
                    {
                        "name": "orderData",
                        "type": "bytes"
                    }
                ],
                "name": "exchange",
                "outputs": [
                    {
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "payable": false,
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "ZERO_EX_COORDINATOR",
                "outputs": [
                    {
                        "name": "",
                        "type": "address"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "EIP712_EXCHANGE_DOMAIN_HASH",
                "outputs": [
                    {
                        "name": "",
                        "type": "bytes32"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "ZERO_EX_TOKEN_PROXY",
                "outputs": [
                    {
                        "name": "",
                        "type": "address"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "EIP712_DOMAIN_HASH",
                "outputs": [
                    {
                        "name": "",
                        "type": "bytes32"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "EIP712_COORDINATOR_DOMAIN_HASH",
                "outputs": [
                    {
                        "name": "",
                        "type": "bytes32"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "name": "zeroExExchange",
                        "type": "address"
                    },
                    {
                        "name": "zeroExCoordinator",
                        "type": "address"
                    },
                    {
                        "name": "zeroExProxy",
                        "type": "address"
                    }
                ],
                "payable": false,
                "stateMutability": "nonpayable",
                "type": "constructor"
            }
        ],
        "devdoc": {
            "author": "0x * dYdX ExchangeWrapper to interface with 0x Version 2.1 Coordinator contract. Sends multiple orders at once. Assumes no ZRX fees.",
            "methods": {
                "exchange(address,address,address,address,uint256,bytes)": {
                    "params": {
                        "makerToken": "Address of makerToken, the token to receive",
                        "orderData": "Arbitrary bytes data for any information to pass to the exchange",
                        "receiver": "Address to set allowance on once the trade has completed",
                        "requestedFillAmount": "Amount of takerToken being paid",
                        "takerToken": "Address of takerToken, the token to pay"
                    },
                    "return": "The amount of makerToken received"
                },
                "getExchangeCost(address,address,uint256,bytes)": {
                    "params": {
                        "desiredMakerToken": "Amount of makerToken requested",
                        "makerToken": "Address of makerToken, the token to receive",
                        "orderData": "Arbitrary bytes data for any information to pass to the exchange",
                        "takerToken": "Address of takerToken, the token to pay"
                    },
                    "return": "Amount of takerToken the needed to complete the exchange"
                },
                "getTransactionHash((uint256,address,bytes))": {
                    "details": "Calculates the EIP712 hash of a 0x transaction using the domain separator of the Exchange contract.",
                    "params": {
                        "transaction": "0x transaction containing salt, signerAddress, and data."
                    },
                    "return": "EIP712 hash of the transaction with the domain separator of this contract."
                },
                "isValidSignature(bytes32,bytes)": {
                    "return": "Magic value required for a successful `Wallet` signature validation in the 0x Exchange v2.1 contract."
                }
            },
            "title": "ZeroExV2MultiOrderExchangeWrapper"
        },
        "evm": {
            "bytecode": {
                "linkReferences": {},
                "object": "0x",
                "opcodes": "",
                "sourceMap": ""
            },
            "deployedBytecode": {
                "linkReferences": {},
                "object": "0x",
                "opcodes": "",
                "sourceMap": ""
            }
        }
    },
    "sources": {
        "ZeroExV2CoordinatorMultiOrderExchangeWrapper.sol": {
            "id": 22
        },
        "SafeMath.sol": {
            "id": 20
        },
        "@0x/contracts-exchange/contracts/src/interfaces/IExchange.sol": {
            "id": 9
        },
        "@0x/contracts-exchange/contracts/src/interfaces/IExchangeCore.sol": {
            "id": 10
        },
        "@0x/contracts-exchange-libs/contracts/src/LibOrder.sol": {
            "id": 7
        },
        "@0x/contracts-exchange-libs/contracts/src/LibEIP712.sol": {
            "id": 5
        },
        "@0x/contracts-exchange-libs/contracts/src/LibFillResults.sol": {
            "id": 6
        },
        "@0x/contracts-utils/contracts/src/SafeMath.sol": {
            "id": 15
        },
        "@0x/contracts-exchange/contracts/src/interfaces/IMatchOrders.sol": {
            "id": 11
        },
        "@0x/contracts-exchange/contracts/src/interfaces/ISignatureValidator.sol": {
            "id": 12
        },
        "@0x/contracts-exchange/contracts/src/interfaces/ITransactions.sol": {
            "id": 13
        },
        "@0x/contracts-exchange/contracts/src/interfaces/IAssetProxyDispatcher.sol": {
            "id": 8
        },
        "@0x/contracts-exchange/contracts/src/interfaces/IWrapperFunctions.sol": {
            "id": 14
        },
        "@0x/contracts-coordinator/contracts/src/interfaces/ICoordinatorCore.sol": {
            "id": 0
        },
        "@0x/contracts-coordinator/contracts/src/libs/LibZeroExTransaction.sol": {
            "id": 4
        },
        "@0x/contracts-coordinator/contracts/src/libs/LibEIP712Domain.sol": {
            "id": 3
        },
        "@0x/contracts-coordinator/contracts/src/libs/LibConstants.sol": {
            "id": 2
        },
        "@0x/contracts-coordinator/contracts/src/interfaces/ITransactions.sol": {
            "id": 1
        },
        "ExchangeWrapper.sol": {
            "id": 17
        },
        "MathHelpers.sol": {
            "id": 19
        },
        "TokenInteract.sol": {
            "id": 21
        },
        "GeneralERC20.sol": {
            "id": 18
        },
        "AdvancedTokenInteract.sol": {
            "id": 16
        }
    },
    "sourceCodes": {
        "ZeroExV2CoordinatorMultiOrderExchangeWrapper.sol": "/* Retrieved from https://raw.githubusercontent.com/0xProject/exchange-wrappers/feat/0x-coordinator-wrapper/contracts/exchange-wrappers/ZeroExV2CoordinatorMultiOrderExchangeWrapper.sol\non August 29, 2019. */\n\npragma solidity 0.5.9;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"./SafeMath.sol\";\nimport { IExchange } from \"@0x/contracts-exchange/contracts/src/interfaces/IExchange.sol\";\nimport { ICoordinatorCore } from \"@0x/contracts-coordinator/contracts/src/interfaces/ICoordinatorCore.sol\";\nimport { LibOrder } from \"@0x/contracts-exchange-libs/contracts/src/LibOrder.sol\";\nimport { LibZeroExTransaction } from \"@0x/contracts-coordinator/contracts/src/libs/LibZeroExTransaction.sol\";\nimport { ExchangeWrapper } from \"./ExchangeWrapper.sol\";\nimport { MathHelpers } from \"./MathHelpers.sol\";\nimport { TokenInteract } from \"./TokenInteract.sol\";\nimport { AdvancedTokenInteract } from \"./AdvancedTokenInteract.sol\";\n\n/**\n * @title ZeroExV2MultiOrderExchangeWrapper\n * @author 0x\n *\n * dYdX ExchangeWrapper to interface with 0x Version 2.1 Coordinator contract. Sends multiple orders at once. Assumes no\n * ZRX fees.\n */\ncontract ZeroExV2CoordinatorMultiOrderExchangeWrapper is\n    LibOrder,\n    LibZeroExTransaction,\n    ExchangeWrapper\n{\n    using SafeMath for uint256;\n    using TokenInteract for address;\n    using AdvancedTokenInteract for address;\n\n    // ============ Constants ============\n\n    // bytes4(keccak256(\"isValidWalletSignature(bytes32,address,bytes)\"))\n    // The 0x Exchange v2.1 contract requires that this value is returned for a successful `Wallet` signature validation\n    bytes4 constant IS_VALID_WALLET_SIGNATURE_MAGIC_VALUE = 0xb0671381;\n\n    // Byte that represents the 0x Exchange v2.1 `Wallet` signature type\n    bytes constant WALLET_SIGNATURE_TYPE = hex\"04\";\n\n    // ============ Structs ============\n\n    struct TokenAmounts {\n        uint256 takerAmount;\n        uint256 makerAmount;\n    }\n\n    struct CoordinatorArgs {\n        Order[] orders;                           // orders for `marketSellOrdersNoThrow`\n        bytes[] orderSignatures;                  // maker signatures for each order\n        uint256 transactionSalt;                  // salt to facilitate randomness in ZeroExTransaction hash\n        uint256[] approvalExpirationTimeSeconds;  // timestamps at which Coordinator approvals expire\n        bytes[] approvalSignatures;               // signatures of Coordinators that approved the transaction\n    }\n\n    struct TokenBalance {\n        address owner;\n        uint256 balance;\n    }\n\n    // ============ State Variables ============\n\n    // address of the ZeroEx V2.1 Exchange\n    address public ZERO_EX_EXCHANGE;\n\n    // address of the ZeroEx V2.1 Coordinator\n    address public ZERO_EX_COORDINATOR;\n\n    // address of the ZeroEx V2 ERC20Proxy\n    address public ZERO_EX_TOKEN_PROXY;\n\n    // ============ Constructor ============\n    constructor(\n        address zeroExExchange,\n        address zeroExCoordinator,\n        address zeroExProxy\n    )\n        public\n    {\n        ZERO_EX_EXCHANGE = zeroExExchange;\n        ZERO_EX_COORDINATOR = zeroExCoordinator;\n        ZERO_EX_TOKEN_PROXY = zeroExProxy;\n    }\n\n    // ============ Public Functions ============\n\n    /**\n     * Exchange some amount of takerToken for makerToken.\n     *\n     * @param  receiver             Address to set allowance on once the trade has completed\n     * @param  makerToken           Address of makerToken, the token to receive\n     * @param  takerToken           Address of takerToken, the token to pay\n     * @param  requestedFillAmount  Amount of takerToken being paid\n     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n     * @return                      The amount of makerToken received\n     */\n    function exchange(\n        address /* tradeOriginator */,\n        address receiver,\n        address makerToken,\n        address takerToken,\n        uint256 requestedFillAmount,\n        bytes calldata orderData\n    )\n        external\n        returns (uint256)\n    {\n        // Ensure that the ERC20Proxy can take the takerTokens from this contract\n        takerToken.ensureAllowance(ZERO_EX_TOKEN_PROXY, requestedFillAmount);\n\n        // Decode `orderData`\n        (TokenAmounts memory priceRatio, CoordinatorArgs memory args) = abi.decode(\n            orderData,\n            (TokenAmounts, CoordinatorArgs)\n        );\n\n        // Query initial balances of makerToken and takerToken\n        // These should be 0 unless tokens were erroneously sent to this contract\n        TokenAmounts memory initialBalances = getTakerMakerTokenBalances(takerToken, makerToken);\n\n        // Encode data for `marketSellOrdersNoThrow`\n        bytes memory marketSellOrdersNoThrowData = abi.encodeWithSelector(\n            IExchange(address(0)).marketSellOrdersNoThrow.selector,\n            args.orders,\n            requestedFillAmount,\n            args.orderSignatures\n        );\n\n        // Construct ZeroExTransaction on behalf of this contract\n        ZeroExTransaction memory transaction = ZeroExTransaction({\n            salt: args.transactionSalt,\n            data: marketSellOrdersNoThrowData,\n            signerAddress: address(this)\n        });\n\n        // Call `marketSellOrdersNoThrow` through the Coordinator contract\n        // Either succeeds or throws\n        ICoordinatorCore(ZERO_EX_COORDINATOR).executeTransaction(\n            transaction,\n            tx.origin,\n            WALLET_SIGNATURE_TYPE,\n            args.approvalExpirationTimeSeconds,\n            args.approvalSignatures\n        );\n\n        // Query balances after fill and calculate amounts filled\n        TokenAmounts memory fillResults = calculateFillResults(takerToken, makerToken, initialBalances);\n\n        // Validate that all taker tokens were sold\n        require(\n            fillResults.takerAmount == requestedFillAmount,\n            \"ZeroExV2CoordinatorMultiOrderExchangeWrapper#exchange: Cannot sell enough taker token\"\n        );\n\n        // Validate that max price is not violated\n        validateTradePrice(\n            priceRatio,\n            fillResults.takerAmount,\n            fillResults.makerAmount\n        );\n\n        // Ensure that the caller can take the makerTokens from this contract\n        makerToken.ensureAllowance(receiver, fillResults.makerAmount);\n\n        return fillResults.makerAmount;\n    }\n\n    /**\n     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\n     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\n     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\n     * than desiredMakerToken\n     *\n     * @param  makerToken         Address of makerToken, the token to receive\n     * @param  takerToken         Address of takerToken, the token to pay\n     * @param  desiredMakerToken  Amount of makerToken requested\n     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\n     * @return                    Amount of takerToken the needed to complete the exchange\n     */\n    function getExchangeCost(\n        address makerToken,\n        address takerToken,\n        uint256 desiredMakerToken,\n        bytes calldata orderData\n    )\n        external\n        view\n        returns (uint256)\n    {\n        // Decode `orderData`\n        (TokenAmounts memory priceRatio, CoordinatorArgs memory args) = abi.decode(\n            orderData,\n            (TokenAmounts, CoordinatorArgs)\n        );\n\n        // Validate that none of the coordinator approvals have expired\n        validateApprovalExpirationTimes(args.approvalExpirationTimeSeconds);\n\n        // Keep running count of how much takerToken is needed until desiredMakerToken is acquired\n        TokenAmounts memory total;\n        total.takerAmount = 0;\n        total.makerAmount = desiredMakerToken;\n\n        // gets the exchange cost. modifies total\n        uint256 takerCost = getExchangeCostInternal(\n            makerToken,\n            args.orders,\n            total\n        );\n\n        // validate that max price will not be violated\n        validateTradePrice(priceRatio, takerCost, desiredMakerToken);\n\n        // return the amount of taker token needed\n        return takerCost;\n    }\n\n    /**\n     * Used to validate `Wallet` signatures for this contract within the 0x Exchange contract.\n     * This function will consider all hash and signature combinations as valid.\n     * @return Magic value required for a successful `Wallet` signature validation in the 0x Exchange v2.1 contract.\n     */\n    function isValidSignature(\n        bytes32 /* hash */,\n        bytes calldata /* signature */\n    )\n        external\n        pure\n        returns (bytes4)\n    {\n        // All signatures are always considered valid\n        // This contract should never hold a balance, but value can be passed through\n        return IS_VALID_WALLET_SIGNATURE_MAGIC_VALUE;\n    }\n\n    // ============ Private Functions ============\n\n    /**\n     * Gets the amount of takerToken required to fill the amount of total.makerToken.\n     * Does not return a value, only modifies the values inside total.\n     */\n    function getExchangeCostInternal(\n        address makerToken,\n        Order[] memory orders,\n        TokenAmounts memory total\n    )\n        private\n        view\n        returns (uint256)\n    {\n        // read exchange address from storage\n        IExchange zeroExExchange = IExchange(ZERO_EX_EXCHANGE);\n\n        // cache balances for makers\n        TokenBalance[] memory balances = new TokenBalance[](orders.length);\n\n        // for all orders\n        for (uint256 i = 0; i < orders.length && total.makerAmount != 0; i++) {\n            Order memory order = orders[i];\n\n            // get order info\n            OrderInfo memory info = zeroExExchange.getOrderInfo(order);\n\n            // ignore unfillable orders\n            if (info.orderStatus != uint8(OrderStatus.FILLABLE)) {\n                continue;\n            }\n\n            // calculate the remaining available taker and maker amounts in the order\n            TokenAmounts memory available;\n            available.takerAmount = order.takerAssetAmount.sub(info.orderTakerAssetFilledAmount);\n            available.makerAmount = MathHelpers.getPartialAmount(\n                available.takerAmount,\n                order.takerAssetAmount,\n                order.makerAssetAmount\n            );\n\n            // bound the remaining available amounts by the maker amount still needed\n            if (available.makerAmount > total.makerAmount) {\n                available.makerAmount = total.makerAmount;\n                available.takerAmount = MathHelpers.getPartialAmountRoundedUp(\n                    order.takerAssetAmount,\n                    order.makerAssetAmount,\n                    available.makerAmount\n                );\n            }\n\n            // ignore orders that the maker will not be able to fill\n            if (!makerHasEnoughTokens(\n                makerToken,\n                balances,\n                order.makerAddress,\n                available.makerAmount)\n            ) {\n                continue;\n            }\n\n            // update the running tallies\n            total.takerAmount = total.takerAmount.add(available.takerAmount);\n            total.makerAmount = total.makerAmount.sub(available.makerAmount);\n        }\n\n        // require that entire amount was bought\n        require(\n            total.makerAmount == 0,\n            \"ZeroExV2CoordinatorMultiOrderExchangeWrapper#getExchangeCostInternal: Cannot buy enough maker token\"\n        );\n\n        return total.takerAmount;\n    }\n\n    /**\n     * Checks and modifies balances to keep track of the expected balance of the maker after filling\n     * each order. Returns true if the maker has enough makerToken left to transfer amount.\n     */\n    function makerHasEnoughTokens(\n        address makerToken,\n        TokenBalance[] memory balances,\n        address makerAddress,\n        uint256 amount\n    )\n        private\n        view\n        returns (bool)\n    {\n        // find the maker's balance in the cache or the first non-populated balance in the cache\n        TokenBalance memory current;\n        uint256 i;\n        for (i = 0; i < balances.length; i++) {\n            current = balances[i];\n            if (\n                current.owner == address(0)\n                || current.owner == makerAddress\n            ) {\n                break;\n            }\n        }\n\n        // if the maker is already in the cache\n        if (current.owner == makerAddress) {\n            if (current.balance >= amount) {\n                current.balance = current.balance.sub(amount);\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        // if the maker is not already in the cache\n        else {\n            uint256 startingBalance = makerToken.balanceOf(makerAddress);\n            if (startingBalance >= amount) {\n                balances[i] = TokenBalance({\n                    owner: makerAddress,\n                    balance: startingBalance.sub(amount)\n                });\n                return true;\n            } else {\n                balances[i] = TokenBalance({\n                    owner: makerAddress,\n                    balance: startingBalance\n                });\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Gets maker and taker token balances of this contract.\n     */\n    function getTakerMakerTokenBalances(\n        address takerToken,\n        address makerToken\n    )\n        private\n        view\n        returns (TokenAmounts memory balances)\n    {\n        address exchangeWrapper = address(this);\n        balances.makerAmount = makerToken.balanceOf(exchangeWrapper);\n        balances.takerAmount = takerToken.balanceOf(exchangeWrapper);\n        return balances;\n    }\n\n    /**\n     * Calculates the fill results based off of the delta in current balances and initial balances\n     * of the maker and taker tokens.\n     */\n    function calculateFillResults(\n        address takerToken,\n        address makerToken,\n        TokenAmounts memory initialBalances\n    )\n        private\n        view\n        returns (TokenAmounts memory fillResults)\n    {\n        TokenAmounts memory currentBalances = getTakerMakerTokenBalances(takerToken, makerToken);\n        fillResults.makerAmount = currentBalances.makerAmount.sub(initialBalances.makerAmount);\n        fillResults.takerAmount = currentBalances.takerAmount.sub(initialBalances.takerAmount);\n        return fillResults;\n    }\n\n    /**\n     * Validates that none of the coordinator approvals have expired\n     */\n    function validateApprovalExpirationTimes(uint256[] memory approvalExpirationTimeSeconds)\n        private\n        view\n    {\n        uint256 length = approvalExpirationTimeSeconds.length;\n        for (uint i = 0; i != length; i++) {\n            require(\n                approvalExpirationTimeSeconds[i] > block.timestamp,\n                \"ZeroExV2CoordinatorMultiOrderExchangeWrapper#validateApprovalExpirationTimes: Expired approval\"\n            );\n        }\n    }\n\n    /**\n     * Validates that a certain takerAmount and makerAmount are within the maxPrice bounds\n     */\n    function validateTradePrice(\n        TokenAmounts memory priceRatio,\n        uint256 takerAmount,\n        uint256 makerAmount\n    )\n        private\n        pure\n    {\n        require(\n            priceRatio.makerAmount == 0 ||\n            takerAmount.mul(priceRatio.makerAmount) <= makerAmount.mul(priceRatio.takerAmount),\n            \"ZeroExV2CoordinatorMultiOrderExchangeWrapper#validateTradePrice: Price greater than maxPrice\"\n        );\n    }\n}\n",
        "SafeMath.sol": "/**\n * Taken from https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/master/contracts/math/SafeMath.sol\n * on August 29, 2019.\n */\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n",
        "@0x/contracts-exchange/contracts/src/interfaces/IExchange.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"./IExchangeCore.sol\";\nimport \"./IMatchOrders.sol\";\nimport \"./ISignatureValidator.sol\";\nimport \"./ITransactions.sol\";\nimport \"./IAssetProxyDispatcher.sol\";\nimport \"./IWrapperFunctions.sol\";\n\n\n// solhint-disable no-empty-blocks\ncontract IExchange is\n    IExchangeCore,\n    IMatchOrders,\n    ISignatureValidator,\n    ITransactions,\n    IAssetProxyDispatcher,\n    IWrapperFunctions\n{}\n",
        "@0x/contracts-exchange/contracts/src/interfaces/IExchangeCore.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-exchange-libs/contracts/src/LibOrder.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibFillResults.sol\";\n\n\ncontract IExchangeCore {\n\n    /// @dev Cancels all orders created by makerAddress with a salt less than or equal to the targetOrderEpoch\n    ///      and senderAddress equal to msg.sender (or null address if msg.sender == makerAddress).\n    /// @param targetOrderEpoch Orders created with a salt less or equal to this value will be cancelled.\n    function cancelOrdersUpTo(uint256 targetOrderEpoch)\n        external;\n\n    /// @dev Fills the input order.\n    /// @param order Order struct containing order specifications.\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n    /// @param signature Proof that order has been created by maker.\n    /// @return Amounts filled and fees paid by maker and taker.\n    function fillOrder(\n        LibOrder.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        public\n        returns (LibFillResults.FillResults memory fillResults);\n\n    /// @dev After calling, the order can not be filled anymore.\n    /// @param order Order struct containing order specifications.\n    function cancelOrder(LibOrder.Order memory order)\n        public;\n\n    /// @dev Gets information about an order: status, hash, and amount filled.\n    /// @param order Order to gather information on.\n    /// @return OrderInfo Information about the order and its state.\n    ///                   See LibOrder.OrderInfo for a complete description.\n    function getOrderInfo(LibOrder.Order memory order)\n        public\n        view\n        returns (LibOrder.OrderInfo memory orderInfo);\n}\n",
        "@0x/contracts-exchange-libs/contracts/src/LibOrder.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\n\nimport \"./LibEIP712.sol\";\n\n\ncontract LibOrder is\n    LibEIP712\n{\n    // Hash for the EIP712 Order Schema\n    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"Order(\",\n        \"address makerAddress,\",\n        \"address takerAddress,\",\n        \"address feeRecipientAddress,\",\n        \"address senderAddress,\",\n        \"uint256 makerAssetAmount,\",\n        \"uint256 takerAssetAmount,\",\n        \"uint256 makerFee,\",\n        \"uint256 takerFee,\",\n        \"uint256 expirationTimeSeconds,\",\n        \"uint256 salt,\",\n        \"bytes makerAssetData,\",\n        \"bytes takerAssetData\",\n        \")\"\n    ));\n\n    // A valid order remains fillable until it is expired, fully filled, or cancelled.\n    // An order's state is unaffected by external factors, like account balances.\n    enum OrderStatus {\n        INVALID,                     // Default value\n        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\n        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\n        FILLABLE,                    // Order is fillable\n        EXPIRED,                     // Order has already expired\n        FULLY_FILLED,                // Order is fully filled\n        CANCELLED                    // Order has been cancelled\n    }\n\n    // solhint-disable max-line-length\n    struct Order {\n        address makerAddress;           // Address that created the order.      \n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.          \n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.      \n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.        \n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.        \n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.          \n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.     \n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\n    }\n    // solhint-enable max-line-length\n\n    struct OrderInfo {\n        uint8 orderStatus;                    // Status that describes order's validity and fillability.\n        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\n    }\n\n    /// @dev Calculates Keccak-256 hash of the order.\n    /// @param order The order structure.\n    /// @return Keccak-256 EIP712 hash of the order.\n    function getOrderHash(Order memory order)\n        internal\n        view\n        returns (bytes32 orderHash)\n    {\n        orderHash = hashEIP712Message(hashOrder(order));\n        return orderHash;\n    }\n\n    /// @dev Calculates EIP712 hash of the order.\n    /// @param order The order structure.\n    /// @return EIP712 hash of the order.\n    function hashOrder(Order memory order)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n        // Assembly for more efficiently computing:\n        // keccak256(abi.encodePacked(\n        //     EIP712_ORDER_SCHEMA_HASH,\n        //     bytes32(order.makerAddress),\n        //     bytes32(order.takerAddress),\n        //     bytes32(order.feeRecipientAddress),\n        //     bytes32(order.senderAddress),\n        //     order.makerAssetAmount,\n        //     order.takerAssetAmount,\n        //     order.makerFee,\n        //     order.takerFee,\n        //     order.expirationTimeSeconds,\n        //     order.salt,\n        //     keccak256(order.makerAssetData),\n        //     keccak256(order.takerAssetData)\n        // ));\n\n        assembly {\n            // Calculate memory addresses that will be swapped out before hashing\n            let pos1 := sub(order, 32)\n            let pos2 := add(order, 320)\n            let pos3 := add(order, 352)\n\n            // Backup\n            let temp1 := mload(pos1)\n            let temp2 := mload(pos2)\n            let temp3 := mload(pos3)\n            \n            // Hash in place\n            mstore(pos1, schemaHash)\n            mstore(pos2, makerAssetDataHash)\n            mstore(pos3, takerAssetDataHash)\n            result := keccak256(pos1, 416)\n            \n            // Restore\n            mstore(pos1, temp1)\n            mstore(pos2, temp2)\n            mstore(pos3, temp3)\n        }\n        return result;\n    }\n}\n",
        "@0x/contracts-exchange-libs/contracts/src/LibEIP712.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\n\n\ncontract LibEIP712 {\n\n    // EIP191 header for EIP712 prefix\n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\n\n    // EIP712 Domain Name value\n    string constant internal EIP712_DOMAIN_NAME = \"0x Protocol\";\n\n    // EIP712 Domain Version value\n    string constant internal EIP712_DOMAIN_VERSION = \"2\";\n\n    // Hash of the EIP712 Domain Separator Schema\n    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"address verifyingContract\",\n        \")\"\n    ));\n\n    // Hash of the EIP712 Domain Separator data\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public EIP712_DOMAIN_HASH;\n\n    constructor ()\n        public\n    {\n        EIP712_DOMAIN_HASH = keccak256(abi.encodePacked(\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n            uint256(address(this))\n        ));\n    }\n\n    /// @dev Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\n    /// @param hashStruct The EIP712 hash struct.\n    /// @return EIP712 hash applied to this EIP712 Domain.\n    function hashEIP712Message(bytes32 hashStruct)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n        // Assembly for more efficient computing:\n        // keccak256(abi.encodePacked(\n        //     EIP191_HEADER,\n        //     EIP712_DOMAIN_HASH,\n        //     hashStruct    \n        // ));\n\n        assembly {\n            // Load free memory pointer\n            let memPtr := mload(64)\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n            // Compute hash\n            result := keccak256(memPtr, 66)\n        }\n        return result;\n    }\n}\n",
        "@0x/contracts-exchange-libs/contracts/src/LibFillResults.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\n\nimport \"@0x/contracts-utils/contracts/src/SafeMath.sol\";\n\n\ncontract LibFillResults is\n    SafeMath\n{\n    struct FillResults {\n        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\n        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\n        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\n        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\n    }\n\n    struct MatchedFillResults {\n        FillResults left;                    // Amounts filled and fees paid of left order.\n        FillResults right;                   // Amounts filled and fees paid of right order.\n        uint256 leftMakerAssetSpreadAmount;  // Spread between price of left and right order, denominated in the left order's makerAsset, paid to taker.\n    }\n\n    /// @dev Adds properties of both FillResults instances.\n    ///      Modifies the first FillResults instance specified.\n    /// @param totalFillResults Fill results instance that will be added onto.\n    /// @param singleFillResults Fill results instance that will be added to totalFillResults.\n    function addFillResults(FillResults memory totalFillResults, FillResults memory singleFillResults)\n        internal\n        pure\n    {\n        totalFillResults.makerAssetFilledAmount = safeAdd(totalFillResults.makerAssetFilledAmount, singleFillResults.makerAssetFilledAmount);\n        totalFillResults.takerAssetFilledAmount = safeAdd(totalFillResults.takerAssetFilledAmount, singleFillResults.takerAssetFilledAmount);\n        totalFillResults.makerFeePaid = safeAdd(totalFillResults.makerFeePaid, singleFillResults.makerFeePaid);\n        totalFillResults.takerFeePaid = safeAdd(totalFillResults.takerFeePaid, singleFillResults.takerFeePaid);\n    }\n}\n",
        "@0x/contracts-utils/contracts/src/SafeMath.sol": "pragma solidity ^0.5.5;\n\n\ncontract SafeMath {\n\n    function safeMul(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(\n            c / a == b,\n            \"UINT256_OVERFLOW\"\n        );\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 c = a / b;\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(\n            b <= a,\n            \"UINT256_UNDERFLOW\"\n        );\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 c = a + b;\n        require(\n            c >= a,\n            \"UINT256_OVERFLOW\"\n        );\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function max256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n}\n",
        "@0x/contracts-exchange/contracts/src/interfaces/IMatchOrders.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-exchange-libs/contracts/src/LibOrder.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibFillResults.sol\";\n\n\ncontract IMatchOrders {\n\n    /// @dev Match two complementary orders that have a profitable spread.\n    ///      Each order is filled at their respective price point. However, the calculations are\n    ///      carried out as though the orders are both being filled at the right order's price point.\n    ///      The profit made by the left order goes to the taker (who matched the two orders).\n    /// @param leftOrder First order to match.\n    /// @param rightOrder Second order to match.\n    /// @param leftSignature Proof that order was created by the left maker.\n    /// @param rightSignature Proof that order was created by the right maker.\n    /// @return matchedFillResults Amounts filled and fees paid by maker and taker of matched orders.\n    function matchOrders(\n        LibOrder.Order memory leftOrder,\n        LibOrder.Order memory rightOrder,\n        bytes memory leftSignature,\n        bytes memory rightSignature\n    )\n        public\n        returns (LibFillResults.MatchedFillResults memory matchedFillResults);\n}\n",
        "@0x/contracts-exchange/contracts/src/interfaces/ISignatureValidator.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\n\n\ncontract ISignatureValidator {\n\n    /// @dev Approves a hash on-chain using any valid signature type.\n    ///      After presigning a hash, the preSign signature type will become valid for that hash and signer.\n    /// @param signerAddress Address that should have signed the given hash.\n    /// @param signature Proof that the hash has been signed by signer.\n    function preSign(\n        bytes32 hash,\n        address signerAddress,\n        bytes calldata signature\n    )\n        external;\n    \n    /// @dev Approves/unnapproves a Validator contract to verify signatures on signer's behalf.\n    /// @param validatorAddress Address of Validator contract.\n    /// @param approval Approval or disapproval of  Validator contract.\n    function setSignatureValidatorApproval(\n        address validatorAddress,\n        bool approval\n    )\n        external;\n\n    /// @dev Verifies that a signature is valid.\n    /// @param hash Message hash that is signed.\n    /// @param signerAddress Address of signer.\n    /// @param signature Proof of signing.\n    /// @return Validity of order signature.\n    function isValidSignature(\n        bytes32 hash,\n        address signerAddress,\n        bytes memory signature\n    )\n        public\n        view\n        returns (bool isValid);\n}\n",
        "@0x/contracts-exchange/contracts/src/interfaces/ITransactions.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\n\n\ncontract ITransactions {\n\n    /// @dev Executes an exchange method call in the context of signer.\n    /// @param salt Arbitrary number to ensure uniqueness of transaction hash.\n    /// @param signerAddress Address of transaction signer.\n    /// @param data AbiV2 encoded calldata.\n    /// @param signature Proof of signer transaction by signer.\n    function executeTransaction(\n        uint256 salt,\n        address signerAddress,\n        bytes calldata data,\n        bytes calldata signature\n    )\n        external;\n}\n",
        "@0x/contracts-exchange/contracts/src/interfaces/IAssetProxyDispatcher.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\n\n\ncontract IAssetProxyDispatcher {\n\n    /// @dev Registers an asset proxy to its asset proxy id.\n    ///      Once an asset proxy is registered, it cannot be unregistered.\n    /// @param assetProxy Address of new asset proxy to register.\n    function registerAssetProxy(address assetProxy)\n        external;\n\n    /// @dev Gets an asset proxy.\n    /// @param assetProxyId Id of the asset proxy.\n    /// @return The asset proxy registered to assetProxyId. Returns 0x0 if no proxy is registered.\n    function getAssetProxy(bytes4 assetProxyId)\n        external\n        view\n        returns (address);\n}\n",
        "@0x/contracts-exchange/contracts/src/interfaces/IWrapperFunctions.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-exchange-libs/contracts/src/LibOrder.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibFillResults.sol\";\n\n\ncontract IWrapperFunctions {\n\n    /// @dev Fills the input order. Reverts if exact takerAssetFillAmount not filled.\n    /// @param order LibOrder.Order struct containing order specifications.\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n    /// @param signature Proof that order has been created by maker.\n    function fillOrKillOrder(\n        LibOrder.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        public\n        returns (LibFillResults.FillResults memory fillResults);\n\n    /// @dev Fills an order with specified parameters and ECDSA signature.\n    ///      Returns false if the transaction would otherwise revert.\n    /// @param order LibOrder.Order struct containing order specifications.\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n    /// @param signature Proof that order has been created by maker.\n    /// @return Amounts filled and fees paid by maker and taker.\n    function fillOrderNoThrow(\n        LibOrder.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        public\n        returns (LibFillResults.FillResults memory fillResults);\n\n    /// @dev Synchronously executes multiple calls of fillOrder.\n    /// @param orders Array of order specifications.\n    /// @param takerAssetFillAmounts Array of desired amounts of takerAsset to sell in orders.\n    /// @param signatures Proofs that orders have been created by makers.\n    /// @return Amounts filled and fees paid by makers and taker.\n    function batchFillOrders(\n        LibOrder.Order[] memory orders,\n        uint256[] memory takerAssetFillAmounts,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    /// @dev Synchronously executes multiple calls of fillOrKill.\n    /// @param orders Array of order specifications.\n    /// @param takerAssetFillAmounts Array of desired amounts of takerAsset to sell in orders.\n    /// @param signatures Proofs that orders have been created by makers.\n    /// @return Amounts filled and fees paid by makers and taker.\n    function batchFillOrKillOrders(\n        LibOrder.Order[] memory orders,\n        uint256[] memory takerAssetFillAmounts,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    /// @dev Fills an order with specified parameters and ECDSA signature.\n    ///      Returns false if the transaction would otherwise revert.\n    /// @param orders Array of order specifications.\n    /// @param takerAssetFillAmounts Array of desired amounts of takerAsset to sell in orders.\n    /// @param signatures Proofs that orders have been created by makers.\n    /// @return Amounts filled and fees paid by makers and taker.\n    function batchFillOrdersNoThrow(\n        LibOrder.Order[] memory orders,\n        uint256[] memory takerAssetFillAmounts,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    /// @dev Synchronously executes multiple calls of fillOrder until total amount of takerAsset is sold by taker.\n    /// @param orders Array of order specifications.\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n    /// @param signatures Proofs that orders have been created by makers.\n    /// @return Amounts filled and fees paid by makers and taker.\n    function marketSellOrders(\n        LibOrder.Order[] memory orders,\n        uint256 takerAssetFillAmount,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    /// @dev Synchronously executes multiple calls of fillOrder until total amount of takerAsset is sold by taker.\n    ///      Returns false if the transaction would otherwise revert.\n    /// @param orders Array of order specifications.\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n    /// @param signatures Proofs that orders have been signed by makers.\n    /// @return Amounts filled and fees paid by makers and taker.\n    function marketSellOrdersNoThrow(\n        LibOrder.Order[] memory orders,\n        uint256 takerAssetFillAmount,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    /// @dev Synchronously executes multiple calls of fillOrder until total amount of makerAsset is bought by taker.\n    /// @param orders Array of order specifications.\n    /// @param makerAssetFillAmount Desired amount of makerAsset to buy.\n    /// @param signatures Proofs that orders have been signed by makers.\n    /// @return Amounts filled and fees paid by makers and taker.\n    function marketBuyOrders(\n        LibOrder.Order[] memory orders,\n        uint256 makerAssetFillAmount,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    /// @dev Synchronously executes multiple fill orders in a single transaction until total amount is bought by taker.\n    ///      Returns false if the transaction would otherwise revert.\n    /// @param orders Array of order specifications.\n    /// @param makerAssetFillAmount Desired amount of makerAsset to buy.\n    /// @param signatures Proofs that orders have been signed by makers.\n    /// @return Amounts filled and fees paid by makers and taker.\n    function marketBuyOrdersNoThrow(\n        LibOrder.Order[] memory orders,\n        uint256 makerAssetFillAmount,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    /// @dev Synchronously cancels multiple orders in a single transaction.\n    /// @param orders Array of order specifications.\n    function batchCancelOrders(LibOrder.Order[] memory orders)\n        public;\n\n    /// @dev Fetches information for all passed in orders\n    /// @param orders Array of order specifications.\n    /// @return Array of OrderInfo instances that correspond to each order.\n    function getOrdersInfo(LibOrder.Order[] memory orders)\n        public\n        view\n        returns (LibOrder.OrderInfo[] memory);\n}\n",
        "@0x/contracts-coordinator/contracts/src/interfaces/ICoordinatorCore.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../libs/LibZeroExTransaction.sol\";\n\n\ncontract ICoordinatorCore {\n\n    /// @dev Executes a 0x transaction that has been signed by the feeRecipients that correspond to each order in the transaction's Exchange calldata.\n    /// @param transaction 0x transaction containing salt, signerAddress, and data.\n    /// @param txOrigin Required signer of Ethereum transaction calling this function.\n    /// @param transactionSignature Proof that the transaction has been signed by the signer.\n    /// @param approvalExpirationTimeSeconds Array of expiration times in seconds for which each corresponding approval signature expires.\n    /// @param approvalSignatures Array of signatures that correspond to the feeRecipients of each order in the transaction's Exchange calldata.\n    function executeTransaction(\n        LibZeroExTransaction.ZeroExTransaction memory transaction,\n        address txOrigin,\n        bytes memory transactionSignature,\n        uint256[] memory approvalExpirationTimeSeconds,\n        bytes[] memory approvalSignatures\n    )\n        public;\n}\n",
        "@0x/contracts-coordinator/contracts/src/libs/LibZeroExTransaction.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\npragma experimental \"ABIEncoderV2\";\n\nimport \"./LibEIP712Domain.sol\";\n\n\ncontract LibZeroExTransaction is\n    LibEIP712Domain\n{\n    // Hash for the EIP712 0x transaction schema\n    // keccak256(abi.encodePacked(\n    //    \"ZeroExTransaction(\",\n    //    \"uint256 salt,\",\n    //    \"address signerAddress,\",\n    //    \"bytes data\",\n    //    \")\"\n    // ));\n    bytes32 constant internal EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH = 0x213c6f636f3ea94e701c0adf9b2624aa45a6c694f9a292c094f9a81c24b5df4c;\n\n    struct ZeroExTransaction {\n        uint256 salt;           // Arbitrary number to ensure uniqueness of transaction hash.\n        address signerAddress;  // Address of transaction signer.\n        bytes data;             // AbiV2 encoded calldata.\n    }\n\n    /// @dev Calculates the EIP712 hash of a 0x transaction using the domain separator of the Exchange contract.\n    /// @param transaction 0x transaction containing salt, signerAddress, and data.\n    /// @return EIP712 hash of the transaction with the domain separator of this contract.\n    function getTransactionHash(ZeroExTransaction memory transaction)\n        public\n        view\n        returns (bytes32 transactionHash)\n    {\n        // Hash the transaction with the domain separator of the Exchange contract.\n        transactionHash = hashEIP712ExchangeMessage(hashZeroExTransaction(transaction));\n        return transactionHash;\n    }\n\n    /// @dev Calculates EIP712 hash of the 0x transaction with no domain separator.\n    /// @param transaction 0x transaction containing salt, signerAddress, and data.\n    /// @return EIP712 hash of the transaction with no domain separator.\n    function hashZeroExTransaction(ZeroExTransaction memory transaction)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        bytes32 schemaHash = EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH;\n        bytes memory data = transaction.data;\n        uint256 salt = transaction.salt;\n        address signerAddress = transaction.signerAddress;\n\n        // Assembly for more efficiently computing:\n        // keccak256(abi.encodePacked(\n        //     EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH,\n        //     transaction.salt,\n        //     uint256(transaction.signerAddress),\n        //     keccak256(transaction.data)\n        // ));\n\n        assembly {\n            // Compute hash of data\n            let dataHash := keccak256(add(data, 32), mload(data))\n\n            // Load free memory pointer\n            let memPtr := mload(64)\n\n            mstore(memPtr, schemaHash)                                                               // hash of schema\n            mstore(add(memPtr, 32), salt)                                                            // salt\n            mstore(add(memPtr, 64), and(signerAddress, 0xffffffffffffffffffffffffffffffffffffffff))  // signerAddress\n            mstore(add(memPtr, 96), dataHash)                                                        // hash of data\n\n            // Compute hash\n            result := keccak256(memPtr, 128)\n        }\n        return result;\n    }\n}\n",
        "@0x/contracts-coordinator/contracts/src/libs/LibEIP712Domain.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\n\nimport \"./LibConstants.sol\";\n\n\ncontract LibEIP712Domain is\n    LibConstants\n{\n\n    // EIP191 header for EIP712 prefix\n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\n\n    // EIP712 Domain Name value for the Coordinator\n    string constant internal EIP712_COORDINATOR_DOMAIN_NAME = \"0x Protocol Coordinator\";\n\n    // EIP712 Domain Version value for the Coordinator\n    string constant internal EIP712_COORDINATOR_DOMAIN_VERSION = \"1.0.0\";\n\n    // EIP712 Domain Name value for the Exchange\n    string constant internal EIP712_EXCHANGE_DOMAIN_NAME = \"0x Protocol\";\n\n    // EIP712 Domain Version value for the Exchange\n    string constant internal EIP712_EXCHANGE_DOMAIN_VERSION = \"2\";\n\n    // Hash of the EIP712 Domain Separator Schema\n    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"address verifyingContract\",\n        \")\"\n    ));\n\n    // Hash of the EIP712 Domain Separator data for the Coordinator\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public EIP712_COORDINATOR_DOMAIN_HASH;\n\n    // Hash of the EIP712 Domain Separator data for the Exchange\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public EIP712_EXCHANGE_DOMAIN_HASH;\n\n    constructor ()\n        public\n    {\n        EIP712_COORDINATOR_DOMAIN_HASH = keccak256(abi.encodePacked(\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n            keccak256(bytes(EIP712_COORDINATOR_DOMAIN_NAME)),\n            keccak256(bytes(EIP712_COORDINATOR_DOMAIN_VERSION)),\n            uint256(address(this))\n        ));\n\n        EIP712_EXCHANGE_DOMAIN_HASH = keccak256(abi.encodePacked(\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n            keccak256(bytes(EIP712_EXCHANGE_DOMAIN_NAME)),\n            keccak256(bytes(EIP712_EXCHANGE_DOMAIN_VERSION)),\n            uint256(address(EXCHANGE))\n        ));\n    }\n\n    /// @dev Calculates EIP712 encoding for a hash struct in the EIP712 domain\n    ///      of this contract.\n    /// @param hashStruct The EIP712 hash struct.\n    /// @return EIP712 hash applied to this EIP712 Domain.\n    function hashEIP712CoordinatorMessage(bytes32 hashStruct)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        return hashEIP712Message(EIP712_COORDINATOR_DOMAIN_HASH, hashStruct);\n    }\n\n    /// @dev Calculates EIP712 encoding for a hash struct in the EIP712 domain\n    ///      of the Exchange contract.\n    /// @param hashStruct The EIP712 hash struct.\n    /// @return EIP712 hash applied to the Exchange EIP712 Domain.\n    function hashEIP712ExchangeMessage(bytes32 hashStruct)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        return hashEIP712Message(EIP712_EXCHANGE_DOMAIN_HASH, hashStruct);\n    }\n\n    /// @dev Calculates EIP712 encoding for a hash struct with a given domain hash.\n    /// @param eip712DomainHash Hash of the domain domain separator data.\n    /// @param hashStruct The EIP712 hash struct.\n    /// @return EIP712 hash applied to the Exchange EIP712 Domain.\n    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        // Assembly for more efficient computing:\n        // keccak256(abi.encodePacked(\n        //     EIP191_HEADER,\n        //     EIP712_DOMAIN_HASH,\n        //     hashStruct\n        // ));\n\n        assembly {\n            // Load free memory pointer\n            let memPtr := mload(64)\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n            // Compute hash\n            result := keccak256(memPtr, 66)\n        }\n        return result;\n    }\n}\n",
        "@0x/contracts-coordinator/contracts/src/libs/LibConstants.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\n\nimport \"../interfaces/ITransactions.sol\";\n\n\ncontract LibConstants {\n\n     // solhint-disable-next-line var-name-mixedcase\n    ITransactions internal EXCHANGE;\n\n    constructor (address _exchange)\n        public\n    {\n        EXCHANGE = ITransactions(_exchange);\n    }\n}\n",
        "@0x/contracts-coordinator/contracts/src/interfaces/ITransactions.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\npragma solidity ^0.5.5;\n\n\ncontract ITransactions {\n\n    /// @dev Executes an exchange method call in the context of signer.\n    /// @param salt Arbitrary number to ensure uniqueness of transaction hash.\n    /// @param signerAddress Address of transaction signer.\n    /// @param data AbiV2 encoded calldata.\n    /// @param signature Proof of signer transaction by signer.\n    function executeTransaction(\n        uint256 salt,\n        address signerAddress,\n        bytes calldata data,\n        bytes calldata signature\n    )\n        external;\n}\n",
        "ExchangeWrapper.sol": "/* Retrieved from https://raw.githubusercontent.com/dydxprotocol/exchange-wrappers/master/contracts/interfaces/ExchangeWrapper.sol\non August 29, 2019. */\n\n/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.9;\n\n\n/**\n * @title ExchangeWrapper\n * @author dYdX\n *\n * Contract interface that Exchange Wrapper smart contracts must implement in order to interface\n * with other smart contracts through a common interface.\n */\ninterface ExchangeWrapper {\n\n    // ============ Public Functions ============\n\n    /**\n     * Exchange some amount of takerToken for makerToken.\n     *\n     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\n     *                              cannot always be trusted as it is set at the discretion of the\n     *                              msg.sender)\n     * @param  receiver             Address to set allowance on once the trade has completed\n     * @param  makerToken           Address of makerToken, the token to receive\n     * @param  takerToken           Address of takerToken, the token to pay\n     * @param  requestedFillAmount  Amount of takerToken being paid\n     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n     * @return                      The amount of makerToken received\n     */\n    function exchange(\n        address tradeOriginator,\n        address receiver,\n        address makerToken,\n        address takerToken,\n        uint256 requestedFillAmount,\n        bytes calldata orderData\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\n     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\n     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\n     * than desiredMakerToken\n     *\n     * @param  makerToken         Address of makerToken, the token to receive\n     * @param  takerToken         Address of takerToken, the token to pay\n     * @param  desiredMakerToken  Amount of makerToken requested\n     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\n     * @return                    Amount of takerToken the needed to complete the transaction\n     */\n    function getExchangeCost(\n        address makerToken,\n        address takerToken,\n        uint256 desiredMakerToken,\n        bytes calldata orderData\n    )\n        external\n        view\n        returns (uint256);\n}\n",
        "MathHelpers.sol": "/* Retrieved from https://raw.githubusercontent.com/dydxprotocol/exchange-wrappers/master/contracts/lib/MathHelpers.sol\non August 29, 2019. */\n\n/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.9;\n\nimport { SafeMath } from \"./SafeMath.sol\";\n\n\n/**\n * @title MathHelpers\n * @author dYdX\n *\n * This library helps with common math functions in Solidity\n */\nlibrary MathHelpers {\n    using SafeMath for uint256;\n\n    /**\n     * Calculates partial value given a numerator and denominator.\n     *\n     * @param  numerator    Numerator\n     * @param  denominator  Denominator\n     * @param  target       Value to calculate partial of\n     * @return              target * numerator / denominator\n     */\n    function getPartialAmount(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return numerator.mul(target).div(denominator);\n    }\n\n    /**\n     * Calculates partial value given a numerator and denominator, rounded up.\n     *\n     * @param  numerator    Numerator\n     * @param  denominator  Denominator\n     * @param  target       Value to calculate partial of\n     * @return              Rounded-up result of target * numerator / denominator\n     */\n    function getPartialAmountRoundedUp(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return divisionRoundedUp(numerator.mul(target), denominator);\n    }\n\n    /**\n     * Calculates division given a numerator and denominator, rounded up.\n     *\n     * @param  numerator    Numerator.\n     * @param  denominator  Denominator.\n     * @return              Rounded-up result of numerator / denominator\n     */\n    function divisionRoundedUp(\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        assert(denominator != 0); // coverage-enable-line\n        if (numerator == 0) {\n            return 0;\n        }\n        return numerator.sub(1).div(denominator).add(1);\n    }\n\n    /**\n     * Calculates and returns the maximum value for a uint256 in solidity\n     *\n     * @return  The maximum value for uint256\n     */\n    function maxUint256(\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return 2 ** 256 - 1;\n    }\n\n    /**\n     * Calculates and returns the maximum value for a uint256 in solidity\n     *\n     * @return  The maximum value for uint256\n     */\n    function maxUint32(\n    )\n        internal\n        pure\n        returns (uint32)\n    {\n        return 2 ** 32 - 1;\n    }\n\n    /**\n     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\n     *\n     * @param  n  The uint256 to get the number of bits in\n     * @return    The number of bits in n\n     */\n    function getNumBits(\n        uint256 n\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 first = 0;\n        uint256 last = 256;\n        while (first < last) {\n            uint256 check = (first + last) / 2;\n            if ((n >> check) == 0) {\n                last = check;\n            } else {\n                first = check + 1;\n            }\n        }\n        assert(first <= 256);\n        return first;\n    }\n}\n",
        "TokenInteract.sol": "/* Retrieved from https://raw.githubusercontent.com/dydxprotocol/exchange-wrappers/master/contracts/lib/TokenInteract.sol\non August 29, 2019. */\n\n/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.9;\n\nimport { GeneralERC20 } from \"./GeneralERC20.sol\";\n\n\n/**\n * @title TokenInteract\n * @author dYdX\n *\n * This library contains basic functions for interacting with ERC20 tokens\n */\nlibrary TokenInteract {\n    function balanceOf(\n        address token,\n        address owner\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return GeneralERC20(token).balanceOf(owner);\n    }\n\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return GeneralERC20(token).allowance(owner, spender);\n    }\n\n    function approve(\n        address token,\n        address spender,\n        uint256 amount\n    )\n        internal\n    {\n        GeneralERC20(token).approve(spender, amount);\n\n        require(\n            checkSuccess(),\n            \"TokenInteract#approve: Approval failed\"\n        );\n    }\n\n    function transfer(\n        address token,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        address from = address(this);\n        if (\n            amount == 0\n            || from == to\n        ) {\n            return;\n        }\n\n        GeneralERC20(token).transfer(to, amount);\n\n        require(\n            checkSuccess(),\n            \"TokenInteract#transfer: Transfer failed\"\n        );\n    }\n\n    function transferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        if (\n            amount == 0\n            || from == to\n        ) {\n            return;\n        }\n\n        GeneralERC20(token).transferFrom(from, to, amount);\n\n        require(\n            checkSuccess(),\n            \"TokenInteract#transferFrom: TransferFrom failed\"\n        );\n    }\n\n    // ============ Private Helper-Functions ============\n\n    /**\n     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n     * function returned 0 bytes or 32 bytes that are not all-zero.\n     */\n    function checkSuccess(\n    )\n        private\n        pure\n        returns (bool)\n    {\n        uint256 returnValue = 0;\n\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            // check number of bytes returned from last function call\n            switch returndatasize\n\n            // no bytes returned: assume success\n            case 0x0 {\n                returnValue := 1\n            }\n\n            // 32 bytes returned: check if non-zero\n            case 0x20 {\n                // copy 32 bytes into scratch space\n                returndatacopy(0x0, 0x0, 0x20)\n\n                // load those bytes into returnValue\n                returnValue := mload(0x0)\n            }\n\n            // not sure what was returned: dont mark as success\n            default { }\n        }\n\n        return returnValue != 0;\n    }\n}\n",
        "GeneralERC20.sol": "/* Retrieved from https://raw.githubusercontent.com/dydxprotocol/exchange-wrappers/master/contracts/lib/GeneralERC20.sol\non August 29, 2019. */\n\n/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.9;\n\n\n/**\n * @title GeneralERC20\n * @author dYdX\n *\n * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\n * that we dont automatically revert when calling non-compliant tokens that have no return value for\n * transfer(), transferFrom(), or approve().\n */\ninterface GeneralERC20 {\n    function totalSupply(\n    )\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(\n        address who\n    )\n        external\n        view\n        returns (uint256);\n\n    function allowance(\n        address owner,\n        address spender\n    )\n        external\n        view\n        returns (uint256);\n\n    function transfer(\n        address to,\n        uint256 value\n    )\n        external;\n\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external;\n\n    function approve(\n        address spender,\n        uint256 value\n    )\n        external;\n}\n",
        "AdvancedTokenInteract.sol": "/* Retrieved from https://raw.githubusercontent.com/dydxprotocol/exchange-wrappers/master/contracts/lib/AdvancedTokenInteract.sol\non August 29, 2019. */\n\n/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.9;\n\nimport { MathHelpers } from \"./MathHelpers.sol\";\nimport { TokenInteract } from \"./TokenInteract.sol\";\n\n\n/**\n * @title AdvancedTokenInteract\n * @author dYdX\n *\n * This library contains advanced functions for interacting with ERC20 tokens\n */\nlibrary AdvancedTokenInteract {\n    using TokenInteract for address;\n\n    /**\n     * Checks if the spender has some amount of allowance. If it doesn't, then set allowance at\n     * the maximum value.\n     *\n     * @param  token    Address of the ERC20 token\n     * @param  spender  Argument of the allowance function\n     * @param  amount   The minimum amount of allownce the the spender should be guaranteed\n     */\n    function ensureAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    )\n        internal\n    {\n        if (token.allowance(address(this), spender) < amount) {\n            token.approve(spender, MathHelpers.maxUint256());\n        }\n    }\n}\n"
    },
    "sourceTreeHashHex": "0x3efc442f0f022304e717ae5b2ffa9b88a02bf109f352e37eec7cd1f5a2adf8fc",
    "compiler": {
        "name": "solc",
        "version": "soljson-v0.5.9+commit.e560f70d.js",
        "settings": {
            "optimizer": {
                "enabled": true,
                "runs": 1000000,
                "details": {
                    "yul": true,
                    "deduplicate": true,
                    "cse": true,
                    "constantOptimizer": true
                }
            },
            "outputSelection": {
                "*": {
                    "*": [
                        "abi",
                        "evm.bytecode.object",
                        "evm.bytecode.sourceMap",
                        "evm.deployedBytecode.object",
                        "evm.deployedBytecode.sourceMap",
                        "devdoc"
                    ]
                }
            },
            "evmVersion": "constantinople",
            "remappings": [
                "@0x/contracts-exchange=/home/gene/dev/0x-monorepo/node_modules/@0x/contracts-exchange",
                "@0x/contracts-exchange-libs=/home/gene/dev/0x-monorepo/node_modules/@0x/contracts-exchange-libs",
                "@0x/contracts-utils=/home/gene/dev/0x-monorepo/node_modules/@0x/contracts-utils",
                "@0x/contracts-coordinator=/home/gene/dev/0x-monorepo/node_modules/@0x/contracts-coordinator"
            ]
        }
    },
    "networks": {}
}
