{
	"schemaVersion": "2.0.0",
	"contractName": "Arbitrage",
	"compilerOutput": {
		"abi": [
			{
				"constant": false,
				"inputs": [
					{
						"name": "tokenAddress",
						"type": "address"
					}
				],
				"name": "setAllowances",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "owner",
				"outputs": [
					{
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "newOwner",
						"type": "address"
					}
				],
				"name": "transferOwnership",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "addresses",
						"type": "address[6]"
					},
					{
						"name": "values",
						"type": "uint256[12]"
					},
					{
						"name": "v",
						"type": "uint8[2]"
					},
					{
						"name": "r",
						"type": "bytes32[2]"
					},
					{
						"name": "s",
						"type": "bytes32[2]"
					}
				],
				"name": "makeAtomicTrade",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"name": "_exchangeAddress",
						"type": "address"
					},
					{
						"name": "_etherDeltaAddress",
						"type": "address"
					},
					{
						"name": "_proxyAddress",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "constructor"
			}
		],
		"evm": {
			"bytecode": {
				"linkReferences": {},
				"object": "0x608060405234801561001057600080fd5b50604051606080611236833981018060405281019080805190602001909291908051906020019092919080519060200190929190505050336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555082600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050506110da8061015c6000396000f300608060405260043610610062576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680633c059027146100675780638da5cb5b146100aa578063f2fde38b14610101578063f41cd05914610144575b600080fd5b34801561007357600080fd5b506100a8600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061019a565b005b3480156100b657600080fd5b506100bf610560565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561010d57600080fd5b50610142600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610585565b005b34801561015057600080fd5b506101986004803603810190808060c001909192919290806101800190919291929080604001909192919290806040019091929192908060400190919291929050505061065a565b005b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156101f757600080fd5b8190508073ffffffffffffffffffffffffffffffffffffffff1663095ea7b3600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b1580156102df57600080fd5b505af11580156102f3573d6000803e3d6000fd5b505050506040513d602081101561030957600080fd5b8101908080519060200190929190505050508073ffffffffffffffffffffffffffffffffffffffff1663095ea7b3600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b15801561040057600080fd5b505af1158015610414573d6000803e3d6000fd5b505050506040513d602081101561042a57600080fd5b8101908080519060200190929190505050508073ffffffffffffffffffffffffffffffffffffffff1663095ea7b36000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b15801561052057600080fd5b505af1158015610534573d6000803e3d6000fd5b505050506040513d602081101561054a57600080fd5b8101908080519060200190929190505050505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156105e057600080fd5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614151561065757806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b50565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156106b557600080fd5b61077b856006806020026040519081016040528092919082600660200280828437820191505050505085600c806020026040519081016040528092919082600c602002808284378201915050505050856002806020026040519081016040528092919082600260200280828437820191505050505085600280602002604051908101604052809291908260026020028082843782019150505050508560028060200260405190810160405280929190826002602002808284378201915050505050610848565b610841856006806020026040519081016040528092919082600660200280828437820191505050505085600c806020026040519081016040528092919082600c602002808284378201915050505050856002806020026040519081016040528092919082600260200280828437820191505050505085600280602002604051908101604052809291908260026020028082843782019150505050508560028060200260405190810160405280929190826002602002808284378201915050505050610bf1565b5050505050565b610850611068565b61085861108b565b600060a06040519081016040528089600060068110151561087557fe5b602002015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018960016006811015156108ba57fe5b602002015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018960026006811015156108ff57fe5b602002015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200189600360068110151561094457fe5b602002015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200189600460068110151561098957fe5b602002015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815250925060c060405190810160405280886000600c811015156109da57fe5b60200201518152602001886001600c811015156109f357fe5b60200201518152602001886002600c81101515610a0c57fe5b60200201518152602001886003600c81101515610a2557fe5b60200201518152602001886004600c81101515610a3e57fe5b60200201518152602001886005600c81101515610a5757fe5b60200201518152509150866006600c81101515610a7057fe5b60200201519050600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663741bcc938484848a6000600281101515610ac757fe5b60200201518a6000600281101515610adb57fe5b60200201518a6000600281101515610aef57fe5b60200201516040518763ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018087600560200280838360005b83811015610b4a578082015181840152602081019050610b2f565b5050505090500186600660200280838360005b83811015610b78578082015181840152602081019050610b5d565b505050509050018581526020018460ff1660ff168152602001836000191660001916815260200182600019166000191681526020019650505050505050600060405180830381600087803b158015610bcf57600080fd5b505af1158015610be3573d6000803e3d6000fd5b505050505050505050505050565b600084600b600c81101515610c0257fe5b60200201519050600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663338b5dea876002600681101515610c5657fe5b6020020151876007600c81101515610c6a57fe5b60200201516040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b158015610cf457600080fd5b505af1158015610d08573d6000803e3d6000fd5b50505050600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630a19b14a876002600681101515610d5957fe5b6020020151876007600c81101515610d6d57fe5b6020020151896003600681101515610d8157fe5b6020020151896008600c81101515610d9557fe5b60200201518a6009600c81101515610da957fe5b60200201518b600a600c81101515610dbd57fe5b60200201518d6005600681101515610dd157fe5b60200201518c6001600281101515610de557fe5b60200201518c6001600281101515610df957fe5b60200201518c6001600281101515610e0d57fe5b60200201518c6040518c63ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808c73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018b81526020018a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018981526020018881526020018781526020018673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018560ff1660ff168152602001846000191660001916815260200183600019166000191681526020018281526020019b505050505050505050505050600060405180830381600087803b158015610f4557600080fd5b505af1158015610f59573d6000803e3d6000fd5b50505050600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639e281a98876003600681101515610faa57fe5b6020020151876008600c81101515610fbe57fe5b60200201516040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b15801561104857600080fd5b505af115801561105c573d6000803e3d6000fd5b50505050505050505050565b60a060405190810160405280600590602082028038833980820191505090505090565b60c0604051908101604052806006906020820280388339808201915050905050905600a165627a7a723058205449833091d9948f2477910c1046f32e6cb4c42abd4a4a6ddbb35a88ce1c248c0029",
				"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x40 MLOAD PUSH1 0x60 DUP1 PUSH2 0x1236 DUP4 CODECOPY DUP2 ADD DUP1 PUSH1 0x40 MSTORE DUP2 ADD SWAP1 DUP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP CALLER PUSH1 0x0 DUP1 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP DUP3 PUSH1 0x1 PUSH1 0x0 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP DUP2 PUSH1 0x2 PUSH1 0x0 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP DUP1 PUSH1 0x3 PUSH1 0x0 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP POP POP POP PUSH2 0x10DA DUP1 PUSH2 0x15C PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x62 JUMPI PUSH1 0x0 CALLDATALOAD PUSH29 0x100000000000000000000000000000000000000000000000000000000 SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0x3C059027 EQ PUSH2 0x67 JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0xAA JUMPI DUP1 PUSH4 0xF2FDE38B EQ PUSH2 0x101 JUMPI DUP1 PUSH4 0xF41CD059 EQ PUSH2 0x144 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x73 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xA8 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0x19A JUMP JUMPDEST STOP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xB6 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xBF PUSH2 0x560 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x10D JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x142 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0x585 JUMP JUMPDEST STOP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x150 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x198 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 DUP1 DUP1 PUSH1 0xC0 ADD SWAP1 SWAP2 SWAP3 SWAP2 SWAP3 SWAP1 DUP1 PUSH2 0x180 ADD SWAP1 SWAP2 SWAP3 SWAP2 SWAP3 SWAP1 DUP1 PUSH1 0x40 ADD SWAP1 SWAP2 SWAP3 SWAP2 SWAP3 SWAP1 DUP1 PUSH1 0x40 ADD SWAP1 SWAP2 SWAP3 SWAP2 SWAP3 SWAP1 DUP1 PUSH1 0x40 ADD SWAP1 SWAP2 SWAP3 SWAP2 SWAP3 SWAP1 POP POP POP PUSH2 0x65A JUMP JUMPDEST STOP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ ISZERO ISZERO PUSH2 0x1F7 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 SWAP1 POP DUP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x95EA7B3 PUSH1 0x2 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF PUSH1 0x40 MLOAD DUP4 PUSH4 0xFFFFFFFF AND PUSH29 0x100000000000000000000000000000000000000000000000000000000 MUL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP3 POP POP POP PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x2DF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x2F3 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x309 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP POP DUP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x95EA7B3 PUSH1 0x3 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF PUSH1 0x40 MLOAD DUP4 PUSH4 0xFFFFFFFF AND PUSH29 0x100000000000000000000000000000000000000000000000000000000 MUL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP3 POP POP POP PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x400 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x414 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x42A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP POP DUP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x95EA7B3 PUSH1 0x0 DUP1 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF PUSH1 0x40 MLOAD DUP4 PUSH4 0xFFFFFFFF AND PUSH29 0x100000000000000000000000000000000000000000000000000000000 MUL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP3 POP POP POP PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x520 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x534 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x54A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 JUMP JUMPDEST PUSH1 0x0 DUP1 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ ISZERO ISZERO PUSH2 0x5E0 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ ISZERO ISZERO PUSH2 0x657 JUMPI DUP1 PUSH1 0x0 DUP1 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 DUP1 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ ISZERO ISZERO PUSH2 0x6B5 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x77B DUP6 PUSH1 0x6 DUP1 PUSH1 0x20 MUL PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP3 PUSH1 0x6 PUSH1 0x20 MUL DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP DUP6 PUSH1 0xC DUP1 PUSH1 0x20 MUL PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP3 PUSH1 0xC PUSH1 0x20 MUL DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP DUP6 PUSH1 0x2 DUP1 PUSH1 0x20 MUL PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP3 PUSH1 0x2 PUSH1 0x20 MUL DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP DUP6 PUSH1 0x2 DUP1 PUSH1 0x20 MUL PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP3 PUSH1 0x2 PUSH1 0x20 MUL DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP DUP6 PUSH1 0x2 DUP1 PUSH1 0x20 MUL PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP3 PUSH1 0x2 PUSH1 0x20 MUL DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP PUSH2 0x848 JUMP JUMPDEST PUSH2 0x841 DUP6 PUSH1 0x6 DUP1 PUSH1 0x20 MUL PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP3 PUSH1 0x6 PUSH1 0x20 MUL DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP DUP6 PUSH1 0xC DUP1 PUSH1 0x20 MUL PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP3 PUSH1 0xC PUSH1 0x20 MUL DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP DUP6 PUSH1 0x2 DUP1 PUSH1 0x20 MUL PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP3 PUSH1 0x2 PUSH1 0x20 MUL DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP DUP6 PUSH1 0x2 DUP1 PUSH1 0x20 MUL PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP3 PUSH1 0x2 PUSH1 0x20 MUL DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP DUP6 PUSH1 0x2 DUP1 PUSH1 0x20 MUL PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP3 PUSH1 0x2 PUSH1 0x20 MUL DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP PUSH2 0xBF1 JUMP JUMPDEST POP POP POP POP POP JUMP JUMPDEST PUSH2 0x850 PUSH2 0x1068 JUMP JUMPDEST PUSH2 0x858 PUSH2 0x108B JUMP JUMPDEST PUSH1 0x0 PUSH1 0xA0 PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 DUP10 PUSH1 0x0 PUSH1 0x6 DUP2 LT ISZERO ISZERO PUSH2 0x875 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP10 PUSH1 0x1 PUSH1 0x6 DUP2 LT ISZERO ISZERO PUSH2 0x8BA JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP10 PUSH1 0x2 PUSH1 0x6 DUP2 LT ISZERO ISZERO PUSH2 0x8FF JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP10 PUSH1 0x3 PUSH1 0x6 DUP2 LT ISZERO ISZERO PUSH2 0x944 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP10 PUSH1 0x4 PUSH1 0x6 DUP2 LT ISZERO ISZERO PUSH2 0x989 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE POP SWAP3 POP PUSH1 0xC0 PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 DUP9 PUSH1 0x0 PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0x9DA JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP2 MSTORE PUSH1 0x20 ADD DUP9 PUSH1 0x1 PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0x9F3 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP2 MSTORE PUSH1 0x20 ADD DUP9 PUSH1 0x2 PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0xA0C JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP2 MSTORE PUSH1 0x20 ADD DUP9 PUSH1 0x3 PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0xA25 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP2 MSTORE PUSH1 0x20 ADD DUP9 PUSH1 0x4 PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0xA3E JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP2 MSTORE PUSH1 0x20 ADD DUP9 PUSH1 0x5 PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0xA57 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP2 MSTORE POP SWAP2 POP DUP7 PUSH1 0x6 PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0xA70 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD SWAP1 POP PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x741BCC93 DUP5 DUP5 DUP5 DUP11 PUSH1 0x0 PUSH1 0x2 DUP2 LT ISZERO ISZERO PUSH2 0xAC7 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP11 PUSH1 0x0 PUSH1 0x2 DUP2 LT ISZERO ISZERO PUSH2 0xADB JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP11 PUSH1 0x0 PUSH1 0x2 DUP2 LT ISZERO ISZERO PUSH2 0xAEF JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD PUSH1 0x40 MLOAD DUP8 PUSH4 0xFFFFFFFF AND PUSH29 0x100000000000000000000000000000000000000000000000000000000 MUL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP8 PUSH1 0x5 PUSH1 0x20 MUL DUP1 DUP4 DUP4 PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0xB4A JUMPI DUP1 DUP3 ADD MLOAD DUP2 DUP5 ADD MSTORE PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH2 0xB2F JUMP JUMPDEST POP POP POP POP SWAP1 POP ADD DUP7 PUSH1 0x6 PUSH1 0x20 MUL DUP1 DUP4 DUP4 PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0xB78 JUMPI DUP1 DUP3 ADD MLOAD DUP2 DUP5 ADD MSTORE PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH2 0xB5D JUMP JUMPDEST POP POP POP POP SWAP1 POP ADD DUP6 DUP2 MSTORE PUSH1 0x20 ADD DUP5 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP4 PUSH1 0x0 NOT AND PUSH1 0x0 NOT AND DUP2 MSTORE PUSH1 0x20 ADD DUP3 PUSH1 0x0 NOT AND PUSH1 0x0 NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP7 POP POP POP POP POP POP POP PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0xBCF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0xBE3 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP POP POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP5 PUSH1 0xB PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0xC02 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD SWAP1 POP PUSH1 0x2 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x338B5DEA DUP8 PUSH1 0x2 PUSH1 0x6 DUP2 LT ISZERO ISZERO PUSH2 0xC56 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP8 PUSH1 0x7 PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0xC6A JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD PUSH1 0x40 MLOAD DUP4 PUSH4 0xFFFFFFFF AND PUSH29 0x100000000000000000000000000000000000000000000000000000000 MUL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP3 POP POP POP PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0xCF4 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0xD08 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x2 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0xA19B14A DUP8 PUSH1 0x2 PUSH1 0x6 DUP2 LT ISZERO ISZERO PUSH2 0xD59 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP8 PUSH1 0x7 PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0xD6D JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP10 PUSH1 0x3 PUSH1 0x6 DUP2 LT ISZERO ISZERO PUSH2 0xD81 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP10 PUSH1 0x8 PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0xD95 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP11 PUSH1 0x9 PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0xDA9 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP12 PUSH1 0xA PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0xDBD JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP14 PUSH1 0x5 PUSH1 0x6 DUP2 LT ISZERO ISZERO PUSH2 0xDD1 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP13 PUSH1 0x1 PUSH1 0x2 DUP2 LT ISZERO ISZERO PUSH2 0xDE5 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP13 PUSH1 0x1 PUSH1 0x2 DUP2 LT ISZERO ISZERO PUSH2 0xDF9 JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP13 PUSH1 0x1 PUSH1 0x2 DUP2 LT ISZERO ISZERO PUSH2 0xE0D JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP13 PUSH1 0x40 MLOAD DUP13 PUSH4 0xFFFFFFFF AND PUSH29 0x100000000000000000000000000000000000000000000000000000000 MUL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP13 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP12 DUP2 MSTORE PUSH1 0x20 ADD DUP11 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP10 DUP2 MSTORE PUSH1 0x20 ADD DUP9 DUP2 MSTORE PUSH1 0x20 ADD DUP8 DUP2 MSTORE PUSH1 0x20 ADD DUP7 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP6 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP5 PUSH1 0x0 NOT AND PUSH1 0x0 NOT AND DUP2 MSTORE PUSH1 0x20 ADD DUP4 PUSH1 0x0 NOT AND PUSH1 0x0 NOT AND DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP12 POP POP POP POP POP POP POP POP POP POP POP POP PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0xF45 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0xF59 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x2 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x9E281A98 DUP8 PUSH1 0x3 PUSH1 0x6 DUP2 LT ISZERO ISZERO PUSH2 0xFAA JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD DUP8 PUSH1 0x8 PUSH1 0xC DUP2 LT ISZERO ISZERO PUSH2 0xFBE JUMPI INVALID JUMPDEST PUSH1 0x20 MUL ADD MLOAD PUSH1 0x40 MLOAD DUP4 PUSH4 0xFFFFFFFF AND PUSH29 0x100000000000000000000000000000000000000000000000000000000 MUL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP3 POP POP POP PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x1048 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x105C JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0xA0 PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 PUSH1 0x5 SWAP1 PUSH1 0x20 DUP3 MUL DUP1 CODESIZE DUP4 CODECOPY DUP1 DUP3 ADD SWAP2 POP POP SWAP1 POP POP SWAP1 JUMP JUMPDEST PUSH1 0xC0 PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 PUSH1 0x6 SWAP1 PUSH1 0x20 DUP3 MUL DUP1 CODESIZE DUP4 CODECOPY DUP1 DUP3 ADD SWAP2 POP POP SWAP1 POP POP SWAP1 JUMP STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 SLOAD 0x49 DUP4 ADDRESS SWAP2 0xd9 SWAP5 DUP16 0x24 PUSH24 0x910C1046F32E6CB4C42ABD4A4A6DDBB35A88CE1C248C0029 ",
				"sourceMap": "427:3407:3:-;;;586:241;8:9:-1;5:2;;;30:1;27;20:12;5:2;586:241:3;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;303:10:6;295:5;;:18;;;;;;;;;;;;;;;;;;712:16:3;692:8;;:37;;;;;;;;;;;;;;;;;;763:18;739:10;;:43;;;;;;;;;;;;;;;;;;807:13;792:12;;:28;;;;;;;;;;;;;;;;;;586:241;;;427:3407;;;;;;"
			}
		}
	},
	"sources": {
		"current/protocol/Exchange/Exchange.sol": {
			"id": 0
		},
		"current/protocol/TokenTransferProxy/TokenTransferProxy.sol": {
			"id": 1
		},
		"current/tokens/Token/Token.sol": {
			"id": 2
		},
		"current/tutorials/Arbitrage/Arbitrage.sol": {
			"id": 3
		},
		"current/tutorials/EtherDelta/AccountLevels.sol": {
			"id": 4
		},
		"current/tutorials/EtherDelta/EtherDelta.sol": {
			"id": 5
		},
		"current/utils/Ownable/Ownable.sol": {
			"id": 6
		},
		"current/utils/SafeMath/SafeMath.sol": {
			"id": 7
		},
		"previous/Ownable/Ownable_v1.sol": {
			"id": 8
		},
		"previous/SafeMath/SafeMath_v1.sol": {
			"id": 9
		},
		"previous/Token/Token_v1.sol": {
			"id": 10
		}
	},
	"sourceCodes": {
		"current/protocol/Exchange/Exchange.sol": "/*\n\n  Copyright 2017 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.4.14;\n\nimport { TokenTransferProxy } from \"../TokenTransferProxy/TokenTransferProxy.sol\";\nimport { Token_v1 as Token } from \"../../../previous/Token/Token_v1.sol\";\nimport { SafeMath_v1 as SafeMath } from \"../../../previous/SafeMath/SafeMath_v1.sol\";\n\n/// @title Exchange - Facilitates exchange of ERC20 tokens.\n/// @author Amir Bandeali - <amir@0xProject.com>, Will Warren - <will@0xProject.com>\ncontract Exchange is SafeMath {\n\n    // Error Codes\n    enum Errors {\n        ORDER_EXPIRED,                    // Order has already expired\n        ORDER_FULLY_FILLED_OR_CANCELLED,  // Order has already been fully filled or cancelled\n        ROUNDING_ERROR_TOO_LARGE,         // Rounding error too large\n        INSUFFICIENT_BALANCE_OR_ALLOWANCE // Insufficient balance or allowance for token transfer\n    }\n\n    string constant public VERSION = \"1.0.0\";\n    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\n\n    address public ZRX_TOKEN_CONTRACT;\n    address public TOKEN_TRANSFER_PROXY_CONTRACT;\n\n    // Mappings of orderHash => amounts of takerTokenAmount filled or cancelled.\n    mapping (bytes32 => uint) public filled;\n    mapping (bytes32 => uint) public cancelled;\n\n    event LogFill(\n        address indexed maker,\n        address taker,\n        address indexed feeRecipient,\n        address makerToken,\n        address takerToken,\n        uint filledMakerTokenAmount,\n        uint filledTakerTokenAmount,\n        uint paidMakerFee,\n        uint paidTakerFee,\n        bytes32 indexed tokens, // keccak256(makerToken, takerToken), allows subscribing to a token pair\n        bytes32 orderHash\n    );\n\n    event LogCancel(\n        address indexed maker,\n        address indexed feeRecipient,\n        address makerToken,\n        address takerToken,\n        uint cancelledMakerTokenAmount,\n        uint cancelledTakerTokenAmount,\n        bytes32 indexed tokens,\n        bytes32 orderHash\n    );\n\n    event LogError(uint8 indexed errorId, bytes32 indexed orderHash);\n\n    struct Order {\n        address maker;\n        address taker;\n        address makerToken;\n        address takerToken;\n        address feeRecipient;\n        uint makerTokenAmount;\n        uint takerTokenAmount;\n        uint makerFee;\n        uint takerFee;\n        uint expirationTimestampInSec;\n        bytes32 orderHash;\n    }\n\n    function Exchange(address _zrxToken, address _tokenTransferProxy) {\n        ZRX_TOKEN_CONTRACT = _zrxToken;\n        TOKEN_TRANSFER_PROXY_CONTRACT = _tokenTransferProxy;\n    }\n\n    /*\n    * Core exchange functions\n    */\n\n    /// @dev Fills the input order.\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfer will fail before attempting.\n    /// @param v ECDSA signature parameter v.\n    /// @param r ECDSA signature parameters r.\n    /// @param s ECDSA signature parameters s.\n    /// @return Total amount of takerToken filled in trade.\n    function fillOrder(\n          address[5] orderAddresses,\n          uint[6] orderValues,\n          uint fillTakerTokenAmount,\n          bool shouldThrowOnInsufficientBalanceOrAllowance,\n          uint8 v,\n          bytes32 r,\n          bytes32 s)\n          public\n          returns (uint filledTakerTokenAmount)\n    {\n        Order memory order = Order({\n            maker: orderAddresses[0],\n            taker: orderAddresses[1],\n            makerToken: orderAddresses[2],\n            takerToken: orderAddresses[3],\n            feeRecipient: orderAddresses[4],\n            makerTokenAmount: orderValues[0],\n            takerTokenAmount: orderValues[1],\n            makerFee: orderValues[2],\n            takerFee: orderValues[3],\n            expirationTimestampInSec: orderValues[4],\n            orderHash: getOrderHash(orderAddresses, orderValues)\n        });\n\n        require(order.taker == address(0) || order.taker == msg.sender);\n        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && fillTakerTokenAmount > 0);\n        require(isValidSignature(\n            order.maker,\n            order.orderHash,\n            v,\n            r,\n            s\n        ));\n\n        if (block.timestamp >= order.expirationTimestampInSec) {\n            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\n            return 0;\n        }\n\n        uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash));\n        filledTakerTokenAmount = min256(fillTakerTokenAmount, remainingTakerTokenAmount);\n        if (filledTakerTokenAmount == 0) {\n            LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash);\n            return 0;\n        }\n\n        if (isRoundingError(filledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount)) {\n            LogError(uint8(Errors.ROUNDING_ERROR_TOO_LARGE), order.orderHash);\n            return 0;\n        }\n\n        if (!shouldThrowOnInsufficientBalanceOrAllowance && !isTransferable(order, filledTakerTokenAmount)) {\n            LogError(uint8(Errors.INSUFFICIENT_BALANCE_OR_ALLOWANCE), order.orderHash);\n            return 0;\n        }\n\n        uint filledMakerTokenAmount = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount);\n        uint paidMakerFee;\n        uint paidTakerFee;\n        filled[order.orderHash] = safeAdd(filled[order.orderHash], filledTakerTokenAmount);\n        require(transferViaTokenTransferProxy(\n            order.makerToken,\n            order.maker,\n            msg.sender,\n            filledMakerTokenAmount\n        ));\n        require(transferViaTokenTransferProxy(\n            order.takerToken,\n            msg.sender,\n            order.maker,\n            filledTakerTokenAmount\n        ));\n        if (order.feeRecipient != address(0)) {\n            if (order.makerFee > 0) {\n                paidMakerFee = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.makerFee);\n                require(transferViaTokenTransferProxy(\n                    ZRX_TOKEN_CONTRACT,\n                    order.maker,\n                    order.feeRecipient,\n                    paidMakerFee\n                ));\n            }\n            if (order.takerFee > 0) {\n                paidTakerFee = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.takerFee);\n                require(transferViaTokenTransferProxy(\n                    ZRX_TOKEN_CONTRACT,\n                    msg.sender,\n                    order.feeRecipient,\n                    paidTakerFee\n                ));\n            }\n        }\n\n        LogFill(\n            order.maker,\n            msg.sender,\n            order.feeRecipient,\n            order.makerToken,\n            order.takerToken,\n            filledMakerTokenAmount,\n            filledTakerTokenAmount,\n            paidMakerFee,\n            paidTakerFee,\n            keccak256(order.makerToken, order.takerToken),\n            order.orderHash\n        );\n        return filledTakerTokenAmount;\n    }\n\n    /// @dev Cancels the input order.\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n    /// @param cancelTakerTokenAmount Desired amount of takerToken to cancel in order.\n    /// @return Amount of takerToken cancelled.\n    function cancelOrder(\n        address[5] orderAddresses,\n        uint[6] orderValues,\n        uint cancelTakerTokenAmount)\n        public\n        returns (uint)\n    {\n        Order memory order = Order({\n            maker: orderAddresses[0],\n            taker: orderAddresses[1],\n            makerToken: orderAddresses[2],\n            takerToken: orderAddresses[3],\n            feeRecipient: orderAddresses[4],\n            makerTokenAmount: orderValues[0],\n            takerTokenAmount: orderValues[1],\n            makerFee: orderValues[2],\n            takerFee: orderValues[3],\n            expirationTimestampInSec: orderValues[4],\n            orderHash: getOrderHash(orderAddresses, orderValues)\n        });\n\n        require(order.maker == msg.sender);\n        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && cancelTakerTokenAmount > 0);\n\n        if (block.timestamp >= order.expirationTimestampInSec) {\n            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\n            return 0;\n        }\n\n        uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash));\n        uint cancelledTakerTokenAmount = min256(cancelTakerTokenAmount, remainingTakerTokenAmount);\n        if (cancelledTakerTokenAmount == 0) {\n            LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash);\n            return 0;\n        }\n\n        cancelled[order.orderHash] = safeAdd(cancelled[order.orderHash], cancelledTakerTokenAmount);\n\n        LogCancel(\n            order.maker,\n            order.feeRecipient,\n            order.makerToken,\n            order.takerToken,\n            getPartialAmount(cancelledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount),\n            cancelledTakerTokenAmount,\n            keccak256(order.makerToken, order.takerToken),\n            order.orderHash\n        );\n        return cancelledTakerTokenAmount;\n    }\n\n    /*\n    * Wrapper functions\n    */\n\n    /// @dev Fills an order with specified parameters and ECDSA signature, throws if specified amount not filled entirely.\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n    /// @param v ECDSA signature parameter v.\n    /// @param r ECDSA signature parameters r.\n    /// @param s ECDSA signature parameters s.\n    function fillOrKillOrder(\n        address[5] orderAddresses,\n        uint[6] orderValues,\n        uint fillTakerTokenAmount,\n        uint8 v,\n        bytes32 r,\n        bytes32 s)\n        public\n    {\n        require(fillOrder(\n            orderAddresses,\n            orderValues,\n            fillTakerTokenAmount,\n            false,\n            v,\n            r,\n            s\n        ) == fillTakerTokenAmount);\n    }\n\n    /// @dev Synchronously executes multiple fill orders in a single transaction.\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\n    /// @param orderValues Array of uint arrays containing individual order values.\n    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n    /// @param v Array ECDSA signature v parameters.\n    /// @param r Array of ECDSA signature r parameters.\n    /// @param s Array of ECDSA signature s parameters.\n    function batchFillOrders(\n        address[5][] orderAddresses,\n        uint[6][] orderValues,\n        uint[] fillTakerTokenAmounts,\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\n        uint8[] v,\n        bytes32[] r,\n        bytes32[] s)\n        public\n    {\n        for (uint i = 0; i < orderAddresses.length; i++) {\n            fillOrder(\n                orderAddresses[i],\n                orderValues[i],\n                fillTakerTokenAmounts[i],\n                shouldThrowOnInsufficientBalanceOrAllowance,\n                v[i],\n                r[i],\n                s[i]\n            );\n        }\n    }\n\n    /// @dev Synchronously executes multiple fillOrKill orders in a single transaction.\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\n    /// @param orderValues Array of uint arrays containing individual order values.\n    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n    /// @param v Array ECDSA signature v parameters.\n    /// @param r Array of ECDSA signature r parameters.\n    /// @param s Array of ECDSA signature s parameters.\n    function batchFillOrKillOrders(\n        address[5][] orderAddresses,\n        uint[6][] orderValues,\n        uint[] fillTakerTokenAmounts,\n        uint8[] v,\n        bytes32[] r,\n        bytes32[] s)\n        public\n    {\n        for (uint i = 0; i < orderAddresses.length; i++) {\n            fillOrKillOrder(\n                orderAddresses[i],\n                orderValues[i],\n                fillTakerTokenAmounts[i],\n                v[i],\n                r[i],\n                s[i]\n            );\n        }\n    }\n\n    /// @dev Synchronously executes multiple fill orders in a single transaction until total fillTakerTokenAmount filled.\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\n    /// @param orderValues Array of uint arrays containing individual order values.\n    /// @param fillTakerTokenAmount Desired total amount of takerToken to fill in orders.\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n    /// @param v Array ECDSA signature v parameters.\n    /// @param r Array of ECDSA signature r parameters.\n    /// @param s Array of ECDSA signature s parameters.\n    /// @return Total amount of fillTakerTokenAmount filled in orders.\n    function fillOrdersUpTo(\n        address[5][] orderAddresses,\n        uint[6][] orderValues,\n        uint fillTakerTokenAmount,\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\n        uint8[] v,\n        bytes32[] r,\n        bytes32[] s)\n        public\n        returns (uint)\n    {\n        uint filledTakerTokenAmount = 0;\n        for (uint i = 0; i < orderAddresses.length; i++) {\n            require(orderAddresses[i][3] == orderAddresses[0][3]); // takerToken must be the same for each order\n            filledTakerTokenAmount = safeAdd(filledTakerTokenAmount, fillOrder(\n                orderAddresses[i],\n                orderValues[i],\n                safeSub(fillTakerTokenAmount, filledTakerTokenAmount),\n                shouldThrowOnInsufficientBalanceOrAllowance,\n                v[i],\n                r[i],\n                s[i]\n            ));\n            if (filledTakerTokenAmount == fillTakerTokenAmount) break;\n        }\n        return filledTakerTokenAmount;\n    }\n\n    /// @dev Synchronously cancels multiple orders in a single transaction.\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\n    /// @param orderValues Array of uint arrays containing individual order values.\n    /// @param cancelTakerTokenAmounts Array of desired amounts of takerToken to cancel in orders.\n    function batchCancelOrders(\n        address[5][] orderAddresses,\n        uint[6][] orderValues,\n        uint[] cancelTakerTokenAmounts)\n        public\n    {\n        for (uint i = 0; i < orderAddresses.length; i++) {\n            cancelOrder(\n                orderAddresses[i],\n                orderValues[i],\n                cancelTakerTokenAmounts[i]\n            );\n        }\n    }\n\n    /*\n    * Constant public functions\n    */\n\n    /// @dev Calculates Keccak-256 hash of order with specified parameters.\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n    /// @return Keccak-256 hash of order.\n    function getOrderHash(address[5] orderAddresses, uint[6] orderValues)\n        public\n        constant\n        returns (bytes32)\n    {\n        return keccak256(\n            address(this),\n            orderAddresses[0], // maker\n            orderAddresses[1], // taker\n            orderAddresses[2], // makerToken\n            orderAddresses[3], // takerToken\n            orderAddresses[4], // feeRecipient\n            orderValues[0],    // makerTokenAmount\n            orderValues[1],    // takerTokenAmount\n            orderValues[2],    // makerFee\n            orderValues[3],    // takerFee\n            orderValues[4],    // expirationTimestampInSec\n            orderValues[5]     // salt\n        );\n    }\n\n    /// @dev Verifies that an order signature is valid.\n    /// @param signer address of signer.\n    /// @param hash Signed Keccak-256 hash.\n    /// @param v ECDSA signature parameter v.\n    /// @param r ECDSA signature parameters r.\n    /// @param s ECDSA signature parameters s.\n    /// @return Validity of order signature.\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s)\n        public\n        constant\n        returns (bool)\n    {\n        return signer == ecrecover(\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\n            v,\n            r,\n            s\n        );\n    }\n\n    /// @dev Checks if rounding error > 0.1%.\n    /// @param numerator Numerator.\n    /// @param denominator Denominator.\n    /// @param target Value to multiply with numerator/denominator.\n    /// @return Rounding error is present.\n    function isRoundingError(uint numerator, uint denominator, uint target)\n        public\n        constant\n        returns (bool)\n    {\n        uint remainder = mulmod(target, numerator, denominator);\n        if (remainder == 0) return false; // No rounding error.\n\n        uint errPercentageTimes1000000 = safeDiv(\n            safeMul(remainder, 1000000),\n            safeMul(numerator, target)\n        );\n        return errPercentageTimes1000000 > 1000;\n    }\n\n    /// @dev Calculates partial value given a numerator and denominator.\n    /// @param numerator Numerator.\n    /// @param denominator Denominator.\n    /// @param target Value to calculate partial of.\n    /// @return Partial value of target.\n    function getPartialAmount(uint numerator, uint denominator, uint target)\n        public\n        constant\n        returns (uint)\n    {\n        return safeDiv(safeMul(numerator, target), denominator);\n    }\n\n    /// @dev Calculates the sum of values already filled and cancelled for a given order.\n    /// @param orderHash The Keccak-256 hash of the given order.\n    /// @return Sum of values already filled and cancelled.\n    function getUnavailableTakerTokenAmount(bytes32 orderHash)\n        public\n        constant\n        returns (uint)\n    {\n        return safeAdd(filled[orderHash], cancelled[orderHash]);\n    }\n\n\n    /*\n    * Internal functions\n    */\n\n    /// @dev Transfers a token using TokenTransferProxy transferFrom function.\n    /// @param token Address of token to transferFrom.\n    /// @param from Address transfering token.\n    /// @param to Address receiving token.\n    /// @param value Amount of token to transfer.\n    /// @return Success of token transfer.\n    function transferViaTokenTransferProxy(\n        address token,\n        address from,\n        address to,\n        uint value)\n        internal\n        returns (bool)\n    {\n        return TokenTransferProxy(TOKEN_TRANSFER_PROXY_CONTRACT).transferFrom(token, from, to, value);\n    }\n\n    /// @dev Checks if any order transfers will fail.\n    /// @param order Order struct of params that will be checked.\n    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n    /// @return Predicted result of transfers.\n    function isTransferable(Order order, uint fillTakerTokenAmount)\n        internal\n        constant  // The called token contracts may attempt to change state, but will not be able to due to gas limits on getBalance and getAllowance.\n        returns (bool)\n    {\n        address taker = msg.sender;\n        uint fillMakerTokenAmount = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount);\n\n        if (order.feeRecipient != address(0)) {\n            bool isMakerTokenZRX = order.makerToken == ZRX_TOKEN_CONTRACT;\n            bool isTakerTokenZRX = order.takerToken == ZRX_TOKEN_CONTRACT;\n            uint paidMakerFee = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.makerFee);\n            uint paidTakerFee = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.takerFee);\n            uint requiredMakerZRX = isMakerTokenZRX ? safeAdd(fillMakerTokenAmount, paidMakerFee) : paidMakerFee;\n            uint requiredTakerZRX = isTakerTokenZRX ? safeAdd(fillTakerTokenAmount, paidTakerFee) : paidTakerFee;\n\n            if (   getBalance(ZRX_TOKEN_CONTRACT, order.maker) < requiredMakerZRX\n                || getAllowance(ZRX_TOKEN_CONTRACT, order.maker) < requiredMakerZRX\n                || getBalance(ZRX_TOKEN_CONTRACT, taker) < requiredTakerZRX\n                || getAllowance(ZRX_TOKEN_CONTRACT, taker) < requiredTakerZRX\n            ) return false;\n\n            if (!isMakerTokenZRX && (   getBalance(order.makerToken, order.maker) < fillMakerTokenAmount // Don't double check makerToken if ZRX\n                                     || getAllowance(order.makerToken, order.maker) < fillMakerTokenAmount)\n            ) return false;\n            if (!isTakerTokenZRX && (   getBalance(order.takerToken, taker) < fillTakerTokenAmount // Don't double check takerToken if ZRX\n                                     || getAllowance(order.takerToken, taker) < fillTakerTokenAmount)\n            ) return false;\n        } else if (   getBalance(order.makerToken, order.maker) < fillMakerTokenAmount\n                   || getAllowance(order.makerToken, order.maker) < fillMakerTokenAmount\n                   || getBalance(order.takerToken, taker) < fillTakerTokenAmount\n                   || getAllowance(order.takerToken, taker) < fillTakerTokenAmount\n        ) return false;\n\n        return true;\n    }\n\n    /// @dev Get token balance of an address.\n    /// @param token Address of token.\n    /// @param owner Address of owner.\n    /// @return Token balance of owner.\n    function getBalance(address token, address owner)\n        internal\n        constant  // The called token contract may attempt to change state, but will not be able to due to an added gas limit.\n        returns (uint)\n    {\n        return Token(token).balanceOf.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner); // Limit gas to prevent reentrancy\n    }\n\n    /// @dev Get allowance of token given to TokenTransferProxy by an address.\n    /// @param token Address of token.\n    /// @param owner Address of owner.\n    /// @return Allowance of token given to TokenTransferProxy by owner.\n    function getAllowance(address token, address owner)\n        internal\n        constant  // The called token contract may attempt to change state, but will not be able to due to an added gas limit.\n        returns (uint)\n    {\n        return Token(token).allowance.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner, TOKEN_TRANSFER_PROXY_CONTRACT); // Limit gas to prevent reentrancy\n    }\n}\n",
		"current/protocol/TokenTransferProxy/TokenTransferProxy.sol": "/*\n\n  Copyright 2017 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.4.11;\n\nimport { Token_v1 as Token } from \"../../../previous/Token/Token_v1.sol\";\nimport { Ownable_v1 as Ownable } from \"../../../previous/Ownable/Ownable_v1.sol\";\n\n/// @title TokenTransferProxy - Transfers tokens on behalf of contracts that have been approved via decentralized governance.\n/// @author Amir Bandeali - <amir@0xProject.com>, Will Warren - <will@0xProject.com>\ncontract TokenTransferProxy is Ownable {\n\n    /// @dev Only authorized addresses can invoke functions with this modifier.\n    modifier onlyAuthorized {\n        require(authorized[msg.sender]);\n        _;\n    }\n\n    modifier targetAuthorized(address target) {\n        require(authorized[target]);\n        _;\n    }\n\n    modifier targetNotAuthorized(address target) {\n        require(!authorized[target]);\n        _;\n    }\n\n    mapping (address => bool) public authorized;\n    address[] public authorities;\n\n    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\n    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\n\n    /*\n     * Public functions\n     */\n\n    /// @dev Authorizes an address.\n    /// @param target Address to authorize.\n    function addAuthorizedAddress(address target)\n        public\n        onlyOwner\n        targetNotAuthorized(target)\n    {\n        authorized[target] = true;\n        authorities.push(target);\n        LogAuthorizedAddressAdded(target, msg.sender);\n    }\n\n    /// @dev Removes authorizion of an address.\n    /// @param target Address to remove authorization from.\n    function removeAuthorizedAddress(address target)\n        public\n        onlyOwner\n        targetAuthorized(target)\n    {\n        delete authorized[target];\n        for (uint i = 0; i < authorities.length; i++) {\n            if (authorities[i] == target) {\n                authorities[i] = authorities[authorities.length - 1];\n                authorities.length -= 1;\n                break;\n            }\n        }\n        LogAuthorizedAddressRemoved(target, msg.sender);\n    }\n\n    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\n    /// @param token Address of token to transfer.\n    /// @param from Address to transfer token from.\n    /// @param to Address to transfer token to.\n    /// @param value Amount of token to transfer.\n    /// @return Success of transfer.\n    function transferFrom(\n        address token,\n        address from,\n        address to,\n        uint value)\n        public\n        onlyAuthorized\n        returns (bool)\n    {\n        return Token(token).transferFrom(from, to, value);\n    }\n\n    /*\n     * Public constant functions\n     */\n\n    /// @dev Gets all authorized addresses.\n    /// @return Array of authorized addresses.\n    function getAuthorizedAddresses()\n        public\n        constant\n        returns (address[])\n    {\n        return authorities;\n    }\n}\n",
		"current/tokens/Token/Token.sol": "pragma solidity ^0.4.18;\n\ncontract Token {\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint _value) public returns (bool) {}\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {}\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint _value) public returns (bool) {}\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) public view returns (uint) {}\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) public view returns (uint) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n",
		"current/tutorials/Arbitrage/Arbitrage.sol": "pragma solidity ^0.4.19;\n\nimport { Exchange } from \"../../protocol/Exchange/Exchange.sol\";\nimport { EtherDelta } from \"../EtherDelta/EtherDelta.sol\";\nimport { Ownable } from \"../../utils/Ownable/Ownable.sol\";\nimport { Token } from \"../../tokens/Token/Token.sol\";\n\n/// @title Arbitrage - Facilitates atomic arbitrage of ERC20 tokens between EtherDelta and 0x Exchange contract.\n/// @author Leonid Logvinov - <leo@0xProject.com>\ncontract Arbitrage is Ownable {\n\n    Exchange exchange;\n    EtherDelta etherDelta;\n    address proxyAddress;\n\n    uint256 constant MAX_UINT = 2**256 - 1;\n\n    function Arbitrage(address _exchangeAddress, address _etherDeltaAddress, address _proxyAddress) {\n        exchange = Exchange(_exchangeAddress);\n        etherDelta = EtherDelta(_etherDeltaAddress);\n        proxyAddress = _proxyAddress;\n    }\n\n    /*\n     * Makes token tradeable by setting an allowance for etherDelta and 0x proxy contract.\n     * Also sets an allowance for the owner of the contracts therefore allowing to withdraw tokens.\n     */\n    function setAllowances(address tokenAddress) external onlyOwner {\n        Token token = Token(tokenAddress);\n        token.approve(address(etherDelta), MAX_UINT);\n        token.approve(proxyAddress, MAX_UINT);\n        token.approve(owner, MAX_UINT);\n    }\n\n    /*\n     * Because of the limits on the number of local variables in Solidity we need to compress parameters while loosing\n     * readability. Scheme of the parameter layout:\n     *\n     * addresses\n     * 0..4 orderAddresses\n     * 5 user\n     *\n     * values\n     * 0..5 orderValues\n     * 6 fillTakerTokenAmount\n     * 7 amountGet\n     * 8 amountGive\n     * 9 expires\n     * 10 nonce\n     * 11 amount\n\n     * signature\n     * exchange then etherDelta\n     */\n    function makeAtomicTrade(\n        address[6] addresses, uint[12] values,\n        uint8[2] v, bytes32[2] r, bytes32[2] s\n    ) external onlyOwner {\n        makeExchangeTrade(addresses, values, v, r, s);\n        makeEtherDeltaTrade(addresses, values, v, r, s);\n    }\n\n    function makeEtherDeltaTrade(\n        address[6] addresses, uint[12] values,\n        uint8[2] v, bytes32[2] r, bytes32[2] s\n    ) internal {\n        uint amount = values[11];\n        etherDelta.depositToken(\n            addresses[2], // tokenGet === makerToken\n            values[7] // amountGet\n        );\n        etherDelta.trade(\n            addresses[2], // tokenGet === makerToken\n            values[7], // amountGet\n            addresses[3], // tokenGive === takerToken\n            values[8], // amountGive\n            values[9], // expires\n            values[10], // nonce\n            addresses[5], // user\n            v[1],\n            r[1],\n            s[1],\n            amount\n        );\n        etherDelta.withdrawToken(\n            addresses[3], // tokenGive === tokenToken\n            values[8] // amountGive\n        );\n    }\n\n    function makeExchangeTrade(\n        address[6] addresses, uint[12] values,\n        uint8[2] v, bytes32[2] r, bytes32[2] s\n    ) internal {\n        address[5] memory orderAddresses = [\n            addresses[0], // maker\n            addresses[1], // taker\n            addresses[2], // makerToken\n            addresses[3], // takerToken\n            addresses[4] // feeRecepient\n        ];\n        uint[6] memory orderValues = [\n            values[0], // makerTokenAmount\n            values[1], // takerTokenAmount\n            values[2], // makerFee\n            values[3], // takerFee\n            values[4], // expirationTimestampInSec\n            values[5]  // salt\n        ];\n        uint fillTakerTokenAmount = values[6]; // fillTakerTokenAmount\n        // Execute Exchange trade. It either succeeds in full or fails and reverts all the changes.\n        exchange.fillOrKillOrder(orderAddresses, orderValues, fillTakerTokenAmount, v[0], r[0], s[0]);\n    }\n}\n",
		"current/tutorials/EtherDelta/AccountLevels.sol": "pragma solidity ^0.4.19;\n\ncontract AccountLevels {\n    //given a user, returns an account level\n    //0 = regular user (pays take fee and make fee)\n    //1 = market maker silver (pays take fee, no make fee, gets rebate)\n    //2 = market maker gold (pays take fee, no make fee, gets entire counterparty's take fee as rebate)\n    function accountLevel(address user) constant returns(uint) {\n        return 0;\n    }\n}\n",
		"current/tutorials/EtherDelta/EtherDelta.sol": "pragma solidity ^0.4.19;\n\nimport { SafeMath } from \"../../utils/SafeMath/SafeMath.sol\";\nimport { AccountLevels } from \"./AccountLevels.sol\";\nimport { Token } from \"../../tokens/Token/Token.sol\";\n\ncontract EtherDelta is SafeMath {\n    address public admin; //the admin address\n    address public feeAccount; //the account that will receive fees\n    address public accountLevelsAddr; //the address of the AccountLevels contract\n    uint public feeMake; //percentage times (1 ether)\n    uint public feeTake; //percentage times (1 ether)\n    uint public feeRebate; //percentage times (1 ether)\n    mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n    mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n    mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n\n    event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\n    event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n    event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n    event Deposit(address token, address user, uint amount, uint balance);\n    event Withdraw(address token, address user, uint amount, uint balance);\n\n    function EtherDelta(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) {\n        admin = admin_;\n        feeAccount = feeAccount_;\n        accountLevelsAddr = accountLevelsAddr_;\n        feeMake = feeMake_;\n        feeTake = feeTake_;\n        feeRebate = feeRebate_;\n    }\n\n    function() {\n        throw;\n    }\n\n    function changeAdmin(address admin_) {\n        if (msg.sender != admin) throw;\n        admin = admin_;\n    }\n\n    function changeAccountLevelsAddr(address accountLevelsAddr_) {\n        if (msg.sender != admin) throw;\n        accountLevelsAddr = accountLevelsAddr_;\n    }\n\n    function changeFeeAccount(address feeAccount_) {\n        if (msg.sender != admin) throw;\n        feeAccount = feeAccount_;\n    }\n\n    function changeFeeMake(uint feeMake_) {\n        if (msg.sender != admin) throw;\n        if (feeMake_ > feeMake) throw;\n        feeMake = feeMake_;\n    }\n\n    function changeFeeTake(uint feeTake_) {\n        if (msg.sender != admin) throw;\n        if (feeTake_ > feeTake || feeTake_ < feeRebate) throw;\n        feeTake = feeTake_;\n    }\n\n    function changeFeeRebate(uint feeRebate_) {\n        if (msg.sender != admin) throw;\n        if (feeRebate_ < feeRebate || feeRebate_ > feeTake) throw;\n        feeRebate = feeRebate_;\n    }\n\n    function deposit() payable {\n        tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n        Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n    }\n\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n        if (!msg.sender.call.value(amount)()) throw;\n        Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n    }\n\n    function depositToken(address token, uint amount) {\n        //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n        if (token==0) throw;\n        if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\n        tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n        Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n    }\n\n    function withdrawToken(address token, uint amount) {\n        if (token==0) throw;\n        if (tokens[token][msg.sender] < amount) throw;\n        tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n        if (!Token(token).transfer(msg.sender, amount)) throw;\n        Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n    }\n\n    function balanceOf(address token, address user) constant returns (uint) {\n        return tokens[token][user];\n    }\n\n    function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {\n        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n        orders[msg.sender][hash] = true;\n        Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\n    }\n\n    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\n        //amount is in amountGet terms\n        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n        if (!(\n            (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\n            block.number <= expires &&\n            safeAdd(orderFills[user][hash], amount) <= amountGet\n        )) throw;\n        tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n        orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\n        Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n    }\n\n    function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n        uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);\n        uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);\n        uint feeRebateXfer = 0;\n        if (accountLevelsAddr != 0x0) {\n            uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);\n            if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether);\n            if (accountLevel==2) feeRebateXfer = feeTakeXfer;\n        }\n        tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));\n        tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(safeAdd(amount, feeRebateXfer), feeMakeXfer));\n        tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeSub(safeAdd(feeMakeXfer, feeTakeXfer), feeRebateXfer));\n        tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\n        tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);\n    }\n\n    function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\n        if (!(\n            tokens[tokenGet][sender] >= amount &&\n            availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n        )) return false;\n        return true;\n    }\n\n    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n        if (!(\n            (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\n            block.number <= expires\n        )) return 0;\n        uint available1 = safeSub(amountGet, orderFills[user][hash]);\n        uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\n        if (available1<available2) return available1;\n        return available2;\n    }\n\n    function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n        return orderFills[user][hash];\n    }\n\n    function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\n        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n        if (!(orders[msg.sender][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == msg.sender)) throw;\n        orderFills[msg.sender][hash] = amountGet;\n        Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n    }\n}\n",
		"current/utils/Ownable/Ownable.sol": "pragma solidity ^0.4.18;\n\n/*\n * Ownable\n *\n * Base contract with an owner.\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n */\n\ncontract Ownable {\n    address public owner;\n\n    function Ownable()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner)\n        public\n        onlyOwner\n    {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n}\n",
		"current/utils/SafeMath/SafeMath.sol": "pragma solidity ^0.4.18;\n\ncontract SafeMath {\n    function safeMul(uint a, uint b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function safeDiv(uint a, uint b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint c = a / b;\n        return c;\n    }\n\n    function safeSub(uint a, uint b)\n        internal\n        pure\n        returns (uint256)\n    {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function safeAdd(uint a, uint b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function max256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n}\n",
		"previous/Ownable/Ownable_v1.sol": "pragma solidity ^0.4.11;\n\n/*\n * Ownable\n *\n * Base contract with an owner.\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n */\n\ncontract Ownable_v1 {\n    address public owner;\n\n    function Ownable_v1() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n}\n",
		"previous/SafeMath/SafeMath_v1.sol": "pragma solidity ^0.4.11;\n\ncontract SafeMath_v1 {\n    function safeMul(uint a, uint b)\n        internal\n        constant\n        returns (uint256)\n    {\n        uint c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function safeDiv(uint a, uint b)\n        internal\n        constant\n        returns (uint256)\n    {\n        uint c = a / b;\n        return c;\n    }\n\n    function safeSub(uint a, uint b)\n        internal\n        constant\n        returns (uint256)\n    {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function safeAdd(uint a, uint b)\n        internal\n        constant\n        returns (uint256)\n    {\n        uint c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b)\n        internal\n        constant\n        returns (uint64)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b)\n        internal\n        constant\n        returns (uint64)\n    {\n        return a < b ? a : b;\n    }\n\n    function max256(uint256 a, uint256 b)\n        internal\n        constant\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b)\n        internal\n        constant\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n}\n",
		"previous/Token/Token_v1.sol": "pragma solidity ^0.4.11;\n\ncontract Token_v1 {\n\n    /// @return total amount of tokens\n    function totalSupply() constant returns (uint supply) {}\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint balance) {}\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint _value) returns (bool success) {}\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint _value) returns (bool success) {}\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n"
	},
	"sourceTreeHashHex": "0x9d4dca59038ae8c995d9d06db8e5184dc52133935ab31834e98ca16a4cba24a5",
	"compiler": {
		"name": "solc",
		"version": "0.4.23",
		"settings": {
			"optimizer": {
				"enabled": false
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"evm.bytecode.object"
					]
				}
			}
		}
	},
	"networks": {}
}