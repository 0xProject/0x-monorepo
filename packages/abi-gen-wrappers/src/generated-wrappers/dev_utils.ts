// tslint:disable:no-consecutive-blank-lines ordered-imports align trailing-comma enum-naming
// tslint:disable:whitespace no-unbound-method no-trailing-whitespace
// tslint:disable:no-unused-variable
import { BaseContract, PromiseWithTransactionHash } from '@0x/base-contract';
import { schemas } from '@0x/json-schemas';
import {
    BlockParam,
    BlockParamLiteral,
    BlockRange,
    CallData,
    ContractAbi,
    ContractArtifact,
    DecodedLogArgs,
    MethodAbi,
    TransactionReceiptWithDecodedLogs,
    TxData,
    TxDataPayable,
    SupportedProvider,
} from 'ethereum-types';
import { BigNumber, classUtils, logUtils, providerUtils } from '@0x/utils';
import {
    AwaitTransactionSuccessOpts,
    EventCallback,
    IndexedFilterValues,
    SendTransactionOpts,
    SimpleContractArtifact,
} from '@0x/types';
import { Web3Wrapper } from '@0x/web3-wrapper';
import { assert } from '@0x/assert';
import * as ethers from 'ethers';
// tslint:enable:no-unused-variable

/* istanbul ignore next */
// tslint:disable:no-parameter-reassignment
// tslint:disable-next-line:class-name
export class DevUtilsContract extends BaseContract {
    /**
     * @ignore
     */
    public static deployedBytecode =
        '0x608060405234801561001057600080fd5b50600436106102c85760003560e01c80639a7e75261161017b578063cafd3a07116100d8578063d46950281161008c578063e4e6e7da11610071578063e4e6e7da14610711578063e77286eb14610732578063ee4f5a9414610754576102c8565b8063d4695028146106cf578063e25cabf7146106ef576102c8565b8063d186037f116100bd578063d186037f14610689578063d36379051461069c578063d3d862d1146106bc576102c8565b8063cafd3a0714610655578063d001c5dc14610676576102c8565b8063acaedc741161012f578063bbb2dcf611610114578063bbb2dcf6146105ef578063bc03f96414610611578063ca49f47c14610632576102c8565b8063acaedc74146105b9578063b43cffe1146105dc576102c8565b8063a0901e5111610160578063a0901e5114610573578063a5cd62ba14610586578063a6627e9f146105a6576102c8565b80639a7e75261461052c5780639eadc8351461054f576102c8565b806346eb65cb116102295780636f83188e116101dd5780637b66ad34116101c25780637b66ad34146104e55780637d727512146105065780638f4ce47914610519576102c8565b80636f83188e146104a15780637914b2ec146104c4576102c8565b8063590aa8751161020e578063590aa8751461044c57806363eb39921461046c578063651290421461047f576102c8565b806346eb65cb146104175780634dfdac201461042c576102c8565b8063314853ff1161028057806332aae3ad1161026557806332aae3ad146103b15780633db6dc61146103d3578063459be5e2146103f6576102c8565b8063314853ff1461037c578063327d30541461039e576102c8565b80630d7b7d76116102b15780630d7b7d7614610319578063165979e11461033a5780632322cf761461035c576102c8565b806302d0aec3146102cd57806304a5618a146102f7575b600080fd5b6102e06102db366004614f2d565b610776565b6040516102ee929190615836565b60405180910390f35b61030a610305366004614f2d565b6107d2565b6040516102ee93929190615931565b61032c610327366004614a5e565b610880565b6040516102ee9291906157e4565b61034d610348366004614f2d565b6108a2565b6040516102ee93929190615a6e565b61036f61036a366004614a5e565b6108ff565b6040516102ee9190615cdc565b61038f61038a366004614f2d565b610927565b6040516102ee9392919061580b565b61032c6103ac366004614f2d565b61096e565b6103c46103bf366004614f2d565b6109b0565b6040516102ee939291906159e2565b6103e66103e1366004614f2d565b610a03565b6040516102ee94939291906157aa565b610409610404366004614f2d565b610a4d565b6040516102ee929190615a56565b61042a610425366004614f2d565b610aa3565b005b61043f61043a366004614985565b610c36565b6040516102ee9190615744565b61045f61045a3660046147fe565b610cb9565b6040516102ee9190615991565b61045f61047a366004614aa2565b610d3d565b61049261048d366004614f2d565b610dc8565b6040516102ee93929190615511565b6104b46104af366004614f2d565b610e02565b6040516102ee9493929190615ae0565b6104d76104d2366004614f2d565b611943565b6040516102ee929190615868565b6104f86104f3366004614f2d565b61197b565b6040516102ee9291906154f7565b61036f610514366004614a5e565b6119b3565b6104d7610527366004614f2d565b6120c8565b61053f61053a366004614f2d565b612158565b6040516102ee9493929190615a9c565b61056261055d366004614f2d565b6121b9565b6040516102ee95949392919061588b565b61043f610581366004614b24565b612264565b610599610594366004614b8a565b6122dd565b6040516102ee919061565d565b61045f6105b4366004614af9565b6123a0565b6105cc6105c7366004614f2d565b612427565b6040516102ee94939291906155b9565b61045f6105ea3660046149d3565b612463565b6106026105fd366004614f2d565b6124f0565b6040516102ee9392919061595c565b61062461061f366004614f2d565b61259d565b6040516102ee9291906157f2565b610645610640366004614f2d565b6125d6565b6040516102ee94939291906158ee565b610668610663366004614f2d565b612687565b6040516102ee929190615ad3565b61043f610684366004614985565b6126d5565b61036f610697366004614a5e565b612743565b6106af6106aa366004614fe4565b612d86565b6040516102ee9190615a89565b61045f6106ca366004614d32565b613323565b6106e26106dd366004614f2d565b61335b565b6040516102ee9190615853565b6107026106fd366004614c0e565b6134a7565b6040516102ee939291906156a9565b61072461071f366004614985565b6135df565b6040516102ee929190615785565b61074561074036600461503c565b6135f8565b6040516102ee93929190615c80565b610767610762366004614f2d565b613832565b6040516102ee93929190615a2c565b60008061078a8361078561386f565b613893565b60006107a360048551866138ed9092919063ffffffff16565b8060200190516107b69190810190614ee0565b909350905060ff811660068111156107ca57fe5b915050915091565b600080806107e6848263ffffffff61393016565b92506001600160e01b031983167f025717920000000000000000000000000000000000000000000000000000000014610854576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161084b90615c49565b60405180910390fd5b61086584601063ffffffff61396416565b915061087884602463ffffffff61399716565b929491935050565b60008061088d84846119b3565b91506108998484612743565b90509250929050565b60008060006108b3846107856139a3565b60006108cc60048651876138ed9092919063ffffffff16565b8060200190516108df9190810190615270565b9094509250905060ff811660028111156108f557fe5b9350509193909250565b600080600061090e8585610880565b9150915061091c82826139c7565b925050505b92915050565b6000606080610938846107856139dd565b835161094e90859060049063ffffffff6138ed16565b8060200190516109619190810190614e80565b9196909550909350915050565b60008061097d83610785613a01565b825161099390849060049063ffffffff6138ed16565b8060200190516109a69190810190614e22565b9094909350915050565b60008060606109c184610785613a25565b60006109da60048651876138ed9092919063ffffffff16565b8060200190516109ed9190810190615224565b9094509250905060ff811660018111156108f557fe5b600080606080610a1585610785613a49565b8451610a2b90869060049063ffffffff6138ed16565b806020019051610a3e9190810190614dde565b92989197509550909350915050565b600080610a5c83610785613a6d565b6000610a7560048551866138ed9092919063ffffffff16565b806020019051610a889190810190615157565b9250905060ff81166003811115610a9b57fe5b925050915091565b6000610ab5828263ffffffff61393016565b90506001600160e01b031981167ff47261b0000000000000000000000000000000000000000000000000000000001415610af957610af2826120c8565b5050610c32565b6001600160e01b031981167f02571792000000000000000000000000000000000000000000000000000000001415610b3c57610b34826107d2565b505050610c32565b6001600160e01b031981167fa7cb5fb7000000000000000000000000000000000000000000000000000000001415610b8157610b77826121b9565b5050505050610c32565b6001600160e01b031981167f94cfcdd7000000000000000000000000000000000000000000000000000000001415610bbc57610b34826124f0565b6001600160e01b031981167fc339d10a000000000000000000000000000000000000000000000000000000001415610c0057610bf7826125d6565b50505050610c32565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161084b90615c49565b5050565b606060008251905080604051908082528060200260200182016040528015610c68578160200160208202803883390190505b50915060005b818114610cb157610c9285858381518110610c8557fe5b6020026020010151612743565b838281518110610c9e57fe5b6020908102919091010152600101610c6e565b505092915050565b6040516060907ff47261b00000000000000000000000000000000000000000000000000000000090610cef9084906024016154e3565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166001600160e01b0319909316929092179091529050919050565b6040516060907fc339d10a0000000000000000000000000000000000000000000000000000000090610d7790869086908690602401615587565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166001600160e01b03199093169290921790915290505b9392505050565b6000806000610dd984610785613a91565b8351610def90859060049063ffffffff6138ed16565b8060200190516109619190810190614853565b60608080806000610e19868263ffffffff61393016565b90506001600160e01b031981167fdedfc1f1000000000000000000000000000000000000000000000000000000001415610e8a576040518060400160405280601181526020017f626174636843616e63656c4f72646572730000000000000000000000000000008152509450611419565b6001600160e01b031981167f9694a402000000000000000000000000000000000000000000000000000000001415610ef9576040518060400160405280600f81526020017f626174636846696c6c4f726465727300000000000000000000000000000000008152509450611419565b6001600160e01b031981167f8ea8dfe4000000000000000000000000000000000000000000000000000000001415610f68576040518060400160405280601681526020017f626174636846696c6c4f72646572734e6f5468726f77000000000000000000008152509450611419565b6001600160e01b031981167fbeee2e14000000000000000000000000000000000000000000000000000000001415610fd7576040518060400160405280601581526020017f626174636846696c6c4f724b696c6c4f726465727300000000000000000000008152509450611419565b6001600160e01b031981167f2da62987000000000000000000000000000000000000000000000000000000001415611046576040518060400160405280600b81526020017f63616e63656c4f726465720000000000000000000000000000000000000000008152509450611419565b6001600160e01b031981167f9b44d5560000000000000000000000000000000000000000000000000000000014156110b5576040518060400160405280600981526020017f66696c6c4f7264657200000000000000000000000000000000000000000000008152509450611419565b6001600160e01b031981167fe14b58c4000000000000000000000000000000000000000000000000000000001415611124576040518060400160405280600f81526020017f66696c6c4f724b696c6c4f7264657200000000000000000000000000000000008152509450611419565b6001600160e01b031981167f78d29ac1000000000000000000000000000000000000000000000000000000001415611193576040518060400160405280601681526020017f6d61726b65744275794f72646572734e6f5468726f77000000000000000000008152509450611419565b6001600160e01b031981167f369da099000000000000000000000000000000000000000000000000000000001415611202576040518060400160405280601781526020017f6d61726b657453656c6c4f72646572734e6f5468726f770000000000000000008152509450611419565b6001600160e01b031981167f8bc8efb3000000000000000000000000000000000000000000000000000000001415611271576040518060400160405280601981526020017f6d61726b65744275794f726465727346696c6c4f724b696c6c000000000000008152509450611419565b6001600160e01b031981167fa6c3bf330000000000000000000000000000000000000000000000000000000014156112e0576040518060400160405280601a81526020017f6d61726b657453656c6c4f726465727346696c6c4f724b696c6c0000000000008152509450611419565b6001600160e01b031981167f88ec79fb00000000000000000000000000000000000000000000000000000000141561134f576040518060400160405280600b81526020017f6d617463684f72646572730000000000000000000000000000000000000000008152509450611419565b6001600160e01b031981167f4f9559b10000000000000000000000000000000000000000000000000000000014806113b057506001600160e01b031981167f2280c91000000000000000000000000000000000000000000000000000000000145b156113e7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161084b90615bdb565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161084b90615ba4565b6001600160e01b031981167fdedfc1f10000000000000000000000000000000000000000000000000000000014156114be57855161146190879060049063ffffffff613ab516565b8060200190516114749190810190614b57565b604080516000808252602082019092529195505b50604080516000808252602082019092529194506114b6565b60608152602001906001900390816114a15790505b50915061193b565b6001600160e01b031981167fbeee2e1400000000000000000000000000000000000000000000000000000000148061151f57506001600160e01b031981167f9694a40200000000000000000000000000000000000000000000000000000000145b8061155357506001600160e01b031981167f8ea8dfe400000000000000000000000000000000000000000000000000000000145b1561156d5761156186613b35565b9195509350915061193b565b6001600160e01b031981167f2da629870000000000000000000000000000000000000000000000000000000014156116555760408051600180825281830190925290816020015b6115bc614131565b8152602001906001900390816115b457505086519094506115e790879060049063ffffffff613ab516565b8060200190516115fa9190810190614fb1565b8460008151811061160757fe5b602002602001018190525060006040519080825280602002602001820160405280156114885781602001602082028038833901905050604080516000808252602082019092529194506114b6565b6001600160e01b031981167fe14b58c40000000000000000000000000000000000000000000000000000000014806116b657506001600160e01b031981167f9b44d55600000000000000000000000000000000000000000000000000000000145b156116c45761156186613b64565b6001600160e01b031981167f78d29ac100000000000000000000000000000000000000000000000000000000148061172557506001600160e01b031981167f369da09900000000000000000000000000000000000000000000000000000000145b8061175957506001600160e01b031981167f8bc8efb300000000000000000000000000000000000000000000000000000000145b8061178d57506001600160e01b031981167fa6c3bf3300000000000000000000000000000000000000000000000000000000145b1561179b5761156186613c5e565b6001600160e01b031981167f88ec79fb00000000000000000000000000000000000000000000000000000000141561193b576117d5614131565b6117dd614131565b6060806117f760048b518c613ab59092919063ffffffff16565b80602001905161180a9190810190615093565b604080516002808252606082019092529498509296509094509250816020015b611832614131565b81526020019060019003908161182a579050509750838860008151811061185557fe5b6020026020010181905250828860018151811061186e57fe5b602090810291909101015260408051600280825260608201909252908160200160208202803883390190505096508360a00151876000815181106118ae57fe5b6020026020010181815250508260a00151876001815181106118cc57fe5b60209081029190910101526040805160028082526060820190925290816020015b60608152602001906001900390816118ed579050509550818660008151811061191257fe5b6020026020010181905250808660018151811061192b57fe5b6020026020010181905250505050505b509193509193565b60008061195283610785613cd2565b825161196890849060049063ffffffff6138ed16565b8060200190516109a69190810190614f04565b60008061198a83610785613cf6565b82516119a090849060049063ffffffff6138ed16565b8060200190516109a6919081019061481a565b6000806119c6838263ffffffff61393016565b90506001600160e01b031981167ff47261b0000000000000000000000000000000000000000000000000000000001415611b3b576000611a0d84601063ffffffff61396416565b6040519091506060907f70a082310000000000000000000000000000000000000000000000000000000090611a469088906024016154e3565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050905060006060836001600160a01b031683604051611ac191906154c7565b600060405180830381855afa9150503d8060008114611afc576040519150601f19603f3d011682016040523d82523d6000602084013e611b01565b606091505b5091509150818015611b14575080516020145b611b1f576000611b30565b611b3081600063ffffffff61399716565b9550505050506120c1565b6001600160e01b031981167f02571792000000000000000000000000000000000000000000000000000000001415611cd657600080611b79856107d2565b6040519194509250606091507f6352211e0000000000000000000000000000000000000000000000000000000090611bb5908490602401615cdc565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050905060006060846001600160a01b031683604051611c3091906154c7565b600060405180830381855afa9150503d8060008114611c6b576040519150601f19603f3d011682016040523d82523d6000602084013e611c70565b606091505b50915091506000828015611c85575081516020145b611c90576000611ca1565b611ca182600c63ffffffff61396416565b9050896001600160a01b0316816001600160a01b031614611cc3576000611cc6565b60015b60ff1697505050505050506120c1565b6001600160e01b031981167fa7cb5fb7000000000000000000000000000000000000000000000000000000001415611eb9576000606080611d16866121b9565b5081519296509094509250905060005b818114611eaf5783516060907efdd58e00000000000000000000000000000000000000000000000000000000908b90879085908110611d6157fe5b6020026020010151604051602401611d7a9291906155ed565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050905060006060876001600160a01b031683604051611df591906154c7565b600060405180830381855afa9150503d8060008114611e30576040519150601f19603f3d011682016040523d82523d6000602084013e611e35565b606091505b50915091506000828015611e4a575081516020145b611e55576000611e66565b611e6682600063ffffffff61399716565b90506000878681518110611e7657fe5b60200260200101518281611e8657fe5b0490508b811080611e9557508b155b15611e9e57809b505b505060019093019250611d26915050565b50505050506120c1565b6001600160e01b031981167fc339d10a00000000000000000000000000000000000000000000000000000000141561200a576040516060907fa85e59e40000000000000000000000000000000000000000000000000000000090611f28908690600090819081906024016159a4565b60408051601f198184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166001600160e01b03199094169390931790925260045491519092506000916001600160a01b031690611f8f9084906154c7565b600060405180830381855afa9150503d8060008114611fca576040519150601f19603f3d011682016040523d82523d6000602084013e611fcf565b606091505b5050905080611fdf576000612001565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5b935050506120c1565b6001600160e01b031981167f94cfcdd70000000000000000000000000000000000000000000000000000000014156120c157606080612048856124f0565b80519194509250905060005b8181146120bc57600061207a8985848151811061206d57fe5b60200260200101516119b3565b9050600085838151811061208a57fe5b6020026020010151828161209a57fe5b049050878110806120a9575087155b156120b2578097505b5050600101612054565b505050505b5092915050565b6000806120db838263ffffffff61393016565b91506001600160e01b031982167ff47261b00000000000000000000000000000000000000000000000000000000014612140576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161084b90615c49565b61215183601063ffffffff61396416565b9050915091565b6000806000606061216b85610785613d1a565b600061218460048751886138ed9092919063ffffffff16565b80602001905161219791908101906151c6565b91965094509250905060ff811660068111156121af57fe5b9450509193509193565b600080606080806121d0868563ffffffff61393016565b94506001600160e01b031985167fa7cb5fb70000000000000000000000000000000000000000000000000000000014612235576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161084b90615c49565b505050506024828101516044840151606485015160848601519496929591820184019490820184019391010190565b6060808251604051908082528060200260200182016040528015612292578160200160208202803883390190505b50905060005b835181146120c1578381815181106122ac57fe5b60200260200101516001600160a01b0316318282815181106122ca57fe5b6020908102919091010152600101612298565b60606000845190508060405190808252806020026020018201604052801561230f578160200160208202803883390190505b50915060005b8181146123975761236086828151811061232b57fe5b602002602001015186838151811061233f57fe5b602002602001015186848151811061235357fe5b6020026020010151612d86565b83828151811061236c57fe5b6020026020010190600481111561237f57fe5b9081600481111561238c57fe5b905250600101612315565b50509392505050565b6040516060907f0257179200000000000000000000000000000000000000000000000000000000906123d890859085906024016155ed565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166001600160e01b031990931692909217909152905092915050565b6000606080606061243a85610785613d3e565b845161245090869060049063ffffffff6138ed16565b806020019051610a3e91908101906148ed565b6040516060907fa7cb5fb7000000000000000000000000000000000000000000000000000000009061249f908790879087908790602401615535565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166001600160e01b0319909316929092179091529050949350505050565b6000606080612505848463ffffffff61393016565b92506001600160e01b031983167f94cfcdd7000000000000000000000000000000000000000000000000000000001461256a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161084b90615c49565b835161258090859060049063ffffffff613ab516565b8060200190516125939190810190614d67565b9395909450915050565b600060606125ad83610785613d62565b82516125c390849060049063ffffffff6138ed16565b8060200190516109a69190810190614e45565b6000806060816125ec858263ffffffff61393016565b93506001600160e01b031984167fc339d10a0000000000000000000000000000000000000000000000000000000014612651576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161084b90615c49565b845161266790869060049063ffffffff613ab516565b80602001905161267a9190810190614895565b9597919650949350915050565b60008061269683610785613d86565b60006126af60048551866138ed9092919063ffffffff16565b8060200190516126c29190810190615157565b9250905060ff81166001811115610a9b57fe5b606060008251905080604051908082528060200260200182016040528015612707578160200160208202803883390190505b50915060005b818114610cb1576127248585838151811061206d57fe5b83828151811061273057fe5b602090810291909101015260010161270d565b600080612756838263ffffffff61393016565b90506001600160e01b031981167f94cfcdd700000000000000000000000000000000000000000000000000000000141561280857606080612796856124f0565b80519194509250905060005b8181146127fd5760006127bb89858481518110610c8557fe5b905060008583815181106127cb57fe5b602002602001015182816127db57fe5b049050878110806127ea575087155b156127f3578097505b50506001016127a2565b506109219350505050565b6001600160e01b031981167ff47261b000000000000000000000000000000000000000000000000000000000141561289357600061284d84601063ffffffff61396416565b6001546040519192506060917fdd62ed3e0000000000000000000000000000000000000000000000000000000091611a469189916001600160a01b0316906024016154f7565b6001600160e01b031981167f02571792000000000000000000000000000000000000000000000000000000001415612b83576000806128d1856107d2565b600254604051929550909350606092507fe985e9c5000000000000000000000000000000000000000000000000000000009161291d918a916001600160a01b03909116906024016154f7565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050905060006060846001600160a01b03168360405161299891906154c7565b600060405180830381855afa9150503d80600081146129d3576040519150601f19603f3d011682016040523d82523d6000602084013e6129d8565b606091505b50915091508115806129ec57508051602014155b80612a085750612a0381600063ffffffff61399716565b600114155b15612b56576040516060907f081812fc0000000000000000000000000000000000000000000000000000000090612a43908790602401615cdc565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050509050856001600160a01b031681604051612aba91906154c7565b600060405180830381855afa9150503d8060008114612af5576040519150601f19603f3d011682016040523d82523d6000602084013e612afa565b606091505b509093509150828015612b0e575081516020145b8015612b3d57506002546001600160a01b0316612b3283600c63ffffffff61396416565b6001600160a01b0316145b612b48576000612b4b565b60015b60ff16975050611eaf565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff965050505050506120c1565b6001600160e01b031981167fa7cb5fb7000000000000000000000000000000000000000000000000000000001415612d2b576000612bc0846121b9565b5050600354604051929450606093507fe985e9c50000000000000000000000000000000000000000000000000000000092612c0a925089916001600160a01b0316906024016154f7565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050905060006060836001600160a01b031683604051612c8591906154c7565b600060405180830381855afa9150503d8060008114612cc0576040519150601f19603f3d011682016040523d82523d6000602084013e612cc5565b606091505b5091509150818015612cd8575080516020145b8015612cf45750612cf081600063ffffffff61399716565b6001145b612cff576000611b30565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9550505050506120c1565b6001600160e01b031981167fc339d10a0000000000000000000000000000000000000000000000000000000014156120c157507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9392505050565b6000612d906141c4565b612e218584600560009054906101000a90046001600160a01b03166001600160a01b0316631ce4c78b6040518163ffffffff1660e01b815260040160206040518083038186803b158015612de357600080fd5b505afa158015612df7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250612e1b919081019061513f565b3a613daa565b60408051600480825260a0820190925291925060609190816020015b6060815260200190600190039081612e3d57505060408051600480825260a082019092529192506060919060208201608080388339505060408051600480825260a08201909252929350606092915060208201608080388339505060408051600480825260a0820190925292935060609291506020820160808038833901905050905088610160015184600081518110612ed357fe5b60200260200101819052508783600081518110612eec57fe5b60200260200101906001600160a01b031690816001600160a01b031681525050886000015182600081518110612f1e57fe5b60200260200101906001600160a01b031690816001600160a01b0316815250508681600081518110612f4c57fe5b60200260200101818152505088610140015184600181518110612f6b57fe5b6020026020010181905250886000015183600181518110612f8857fe5b60200260200101906001600160a01b031690816001600160a01b0316815250508782600181518110612fb657fe5b60200260200101906001600160a01b031690816001600160a01b031681525050846000015181600181518110612fe857fe5b602002602001018181525050886101a001518460028151811061300757fe5b6020026020010181905250878360028151811061302057fe5b60200260200101906001600160a01b031690816001600160a01b03168152505088604001518260028151811061305257fe5b60200260200101906001600160a01b031690816001600160a01b03168152505084606001518160028151811061308457fe5b602002602001018181525050886101800151846003815181106130a357fe5b60200260200101819052508860000151836003815181106130c057fe5b60200260200101906001600160a01b031690816001600160a01b0316815250508860400151826003815181106130f257fe5b60200260200101906001600160a01b031690816001600160a01b03168152505084604001518160038151811061312457fe5b60209081029190910101526040516060907fb04fbddd000000000000000000000000000000000000000000000000000000009061316b908790879087908790602401615606565b60408051601f198184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166001600160e01b03199094169390931790925260055491519092506060916001600160a01b0316906131d29084906154c7565b6000604051808303816000865af19150503d806000811461320f576040519150601f19603f3d011682016040523d82523d6000602084013e613214565b606091505b5091506000905061322b828263ffffffff61393016565b9050613235613a25565b6001600160e01b031982811691161415613277576000613254836109b0565b5091505060ff8116600481111561326757fe5b9950505050505050505050610dc1565b61327f6139dd565b6001600160e01b0319828116911614156132b257600061329e83610927565b509091505060ff8116600481111561326757fe5b815160208301207ff43f26ea5a94b478394a975e856464913dc1a8a1ca70939d974aa7c238aa0ce014156132f157600498505050505050505050610dc1565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161084b90615b6d565b6040516060907f94cfcdd700000000000000000000000000000000000000000000000000000000906123d89085908590602401615757565b600061336d828263ffffffff61393016565b90506001600160e01b031981167ff47261b00000000000000000000000000000000000000000000000000000000014806133d057506001600160e01b031981167f0257179200000000000000000000000000000000000000000000000000000000145b8061340457506001600160e01b031981167fa7cb5fb700000000000000000000000000000000000000000000000000000000145b8061343857506001600160e01b031981167f94cfcdd700000000000000000000000000000000000000000000000000000000145b8061346c57506001600160e01b031981167fc339d10a00000000000000000000000000000000000000000000000000000000145b6134a2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161084b90615c49565b919050565b6060806060600085519050806040519080825280602002602001820160405280156134ec57816020015b6134d96141f3565b8152602001906001900390816134d15790505b50935080604051908082528060200260200182016040528015613519578160200160208202803883390190505b50925080604051908082528060200260200182016040528015613546578160200160208202803883390190505b50915060005b8181146135d65761358387828151811061356257fe5b602002602001015187838151811061357657fe5b60200260200101516135f8565b875188908590811061359157fe5b602002602001018785815181106135a457fe5b602002602001018786815181106135b757fe5b931515602094850291909101909301929092529190525260010161354c565b50509250925092565b6060806135ec84846126d5565b91506108998484610c36565b6136006141f3565b600080546040517f9d3fa4b900000000000000000000000000000000000000000000000000000000815282916001600160a01b031690639d3fa4b99061364a908890600401615ca4565b60606040518083038186803b15801561366257600080fd5b505afa158015613676573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525061369a9190810190614f60565b85516000546040517fa12dcc6f00000000000000000000000000000000000000000000000000000000815292955090916001600160a01b039091169063a12dcc6f906136ec9089908990600401615cb7565b60206040518083038186803b15801561370457600080fd5b505afa158015613718573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525061373c9190810190614dbe565b9150600061374f828861014001516108ff565b60a088015160c08901516101808a01516101408b01519394509192909160009161377e9163ffffffff613e2116565b156137ab576137a48461379e848d60800151613e4690919063ffffffff16565b85613e62565b9050613804565b816137bf576137a4848b6080015185613e62565b60006137d0868c61018001516108ff565b905060006137e3868d6080015187613e62565b905060006137f2838688613e62565b90506137fe82826139c7565b93505050505b61382461381e896040015185613e8c90919063ffffffff16565b826139c7565b965050505050509250925092565b600080600061384384610785613eab565b600061385c60048651876138ed9092919063ffffffff16565b8060200190516108df9190810190615184565b7ffdb6ca8d0000000000000000000000000000000000000000000000000000000090565b60006138a0836000613930565b90506001600160e01b0319808216908316146138e8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161084b90615c12565b505050565b60608183111561390b5761390b61390660008585613ecf565b613eee565b8351821115613924576139246139066001848751613ecf565b50819003910190815290565b60008160040183511015613951576139516139066003855185600401613ecf565b5001602001516001600160e01b03191690565b60008160140183511015613985576139856139066004855185601401613ecf565b5001601401516001600160a01b031690565b6000610dc18383613ef6565b7f18e4b1410000000000000000000000000000000000000000000000000000000090565b60008183106139d65781610dc1565b5090919050565b7f4678472b0000000000000000000000000000000000000000000000000000000090565b7fb6555d6f0000000000000000000000000000000000000000000000000000000090565b7f488219a60000000000000000000000000000000000000000000000000000000090565b7f1b8388f70000000000000000000000000000000000000000000000000000000090565b7fe94a7ed00000000000000000000000000000000000000000000000000000000090565b7f4ad312750000000000000000000000000000000000000000000000000000000090565b606081831115613ace57613ace61390660008585613ecf565b8351821115613ae757613ae76139066001848751613ecf565b8282036040519080825280601f01601f191660200182016040528015613b14576020820181803883390190505b509050610dc1613b2382613f20565b84613b2d87613f20565b018351613f26565b6060806060613b516004855186613ab59092919063ffffffff16565b8060200190516109619190810190614c65565b60408051600180825281830190925260609182918291816020015b613b87614131565b815260200190600190039081613b7f5750506040805160018082528183019092529194506020808301908038833901905050604080516001808252818301909252919350816020015b6060815260200190600190039081613bd05750508451909150613bfd90859060049063ffffffff613ab516565b806020019051613c1091908101906150ec565b85600081518110613c1d57fe5b6020026020010185600081518110613c3157fe5b6020026020010185600081518110613c4557fe5b6020908102919091010192909252919052529193909250565b604080516001808252818301909252606091829182916020808301908038833950508551919350613c9a9186915060049063ffffffff613ab516565b806020019051613cad9190810190614cdf565b84518590600090613cba57fe5b60209081029190910101919091529095929450925050565b7f11c7b7200000000000000000000000000000000000000000000000000000000090565b7fa15c0d060000000000000000000000000000000000000000000000000000000090565b7f7e5a23180000000000000000000000000000000000000000000000000000000090565b7f5bd0428d0000000000000000000000000000000000000000000000000000000090565b7f20d11f610000000000000000000000000000000000000000000000000000000090565b7ff59851840000000000000000000000000000000000000000000000000000000090565b613db26141c4565b6020810184905260a08501516080860151613dce918691613fcb565b815260a085015160c0860151613de5918691613fcb565b604082015260a085015160e0860151613dff918691613fcb565b6060820152613e14828463ffffffff613fff16565b6080820152949350505050565b600081518351148015610dc15750508051602091820120825192909101919091201490565b600082820183811015610dc157610dc16139066000868661402c565b6000613e8483613e78868563ffffffff613fff16565b9063ffffffff61404b16565b949350505050565b600082821115613ea557613ea56139066002858561402c565b50900390565b7fe53c76c80000000000000000000000000000000000000000000000000000000090565b6060632800659560e01b848484604051602401610d7793929190615a7b565b805160208201fd5b60008160200183511015613f1757613f176139066005855185602001613ecf565b50016020015190565b60200190565b6020811015613f50576001816020036101000a0380198351168185511680821786525050506138e8565b82821415613f5d576138e8565b82821115613f975760208103905080820181840181515b82851015613f8f578451865260209586019590940193613f74565b9052506138e8565b60208103905080820181840183515b81861215613fc25782518252601f199283019290910190613fa6565b85525050505050565b6000613fd8848484614075565b15613feb57613feb6139068585856140db565b613e8483613e78868563ffffffff613fff16565b60008261400e57506000610921565b8282028284828161401b57fe5b0414610dc157610dc1613906600186865b606063e946c1bb60e01b848484604051602401610d7793929190615a0a565b600081614061576140616139066003858561402c565b600082848161406c57fe5b04949350505050565b600082614087576140876139066140fa565b811580614092575083155b1561409f57506000610dc1565b600083806140a957fe5b85840990506140be858463ffffffff613fff16565b6140d0826103e863ffffffff613fff16565b101595945050505050565b606063339f3de260e01b848484604051602401610d7793929190615ce5565b60408051808201909152600481527fa791837c00000000000000000000000000000000000000000000000000000000602082015290565b604051806101c0016040528060006001600160a01b0316815260200160006001600160a01b0316815260200160006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001606081526020016060815260200160608152602001606081525090565b6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b604080516060810182526000808252602082018190529181019190915290565b803561092181615dc1565b805161092181615dc1565b600082601f830112614239578081fd5b813561424c61424782615d22565b615cfb565b81815291506020808301908481018184028601820187101561426d57600080fd5b60005b848110156120bc57813561428381615dc1565b84529282019290820190600101614270565b600082601f8301126142a5578081fd5b81516142b361424782615d22565b8181529150602080830190840160005b838110156142f0576142db8760208451890101614515565b835260209283019291909101906001016142c3565b5050505092915050565b600082601f83011261430a578081fd5b813561431861424782615d22565b8181529150602080830190840160005b838110156142f05761434087602084358901016144c7565b83526020928301929190910190600101614328565b600082601f830112614365578081fd5b815161437361424782615d22565b8181529150602080830190840160005b838110156142f05761439b87602084518901016146aa565b83526020928301929190910190600101614383565b600082601f8301126143c0578081fd5b81356143ce61424782615d22565b8181529150602080830190840160005b838110156142f0576143f6876020843589010161455b565b835260209283019291909101906001016143de565b600082601f83011261441b578081fd5b815161442961424782615d22565b81815291506020808301908481018184028601820187101561444a57600080fd5b60005b848110156120bc5781518452928201929082019060010161444d565b600082601f830112614479578081fd5b813561448761424782615d22565b8181529150602080830190848101818402860182018710156144a857600080fd5b60005b848110156120bc578135845292820192908201906001016144ab565b600082601f8301126144d7578081fd5b81356144e561424782615d42565b91508082528360208285010111156144fc57600080fd5b8060208401602084013760009082016020015292915050565b600082601f830112614525578081fd5b815161453361424782615d42565b915080825283602082850101111561454a57600080fd5b6120c1816020840160208601615d66565b60006101c080838503121561456e578182fd5b61457781615cfb565b9150506145848383614213565b81526145938360208401614213565b60208201526145a58360408401614213565b60408201526145b78360608401614213565b60608201526080820135608082015260a082013560a082015260c082013560c082015260e082013560e08201526101008083013581830152506101208083013581830152506101408083013567ffffffffffffffff8082111561461957600080fd5b614625868387016144c7565b8385015261016092508285013591508082111561464157600080fd5b61464d868387016144c7565b8385015261018092508285013591508082111561466957600080fd5b614675868387016144c7565b838501526101a092508285013591508082111561469157600080fd5b5061469e858286016144c7565b82840152505092915050565b60006101c08083850312156146bd578182fd5b6146c681615cfb565b9150506146d3838361421e565b81526146e2836020840161421e565b60208201526146f4836040840161421e565b6040820152614706836060840161421e565b60608201526080820151608082015260a082015160a082015260c082015160c082015260e082015160e08201526101008083015181830152506101208083015181830152506101408083015167ffffffffffffffff8082111561476857600080fd5b61477486838701614515565b8385015261016092508285015191508082111561479057600080fd5b61479c86838701614515565b838501526101809250828501519150808211156147b857600080fd5b6147c486838701614515565b838501526101a09250828501519150808211156147e057600080fd5b5061469e85828601614515565b805160ff8116811461092157600080fd5b60006020828403121561480f578081fd5b8135610dc181615dc1565b6000806040838503121561482c578081fd5b825161483781615dc1565b602084015190925061484881615dc1565b809150509250929050565b600080600060608486031215614867578081fd5b835161487281615dc1565b602085015190935061488381615dc1565b80925050604084015190509250925092565b6000806000606084860312156148a9578081fd5b83516148b481615dc1565b602085015190935067ffffffffffffffff8111156148d0578182fd5b6148dc86828701614515565b925050604084015190509250925092565b60008060008060808587031215614902578182fd5b845161490d81615dc1565b602086015190945067ffffffffffffffff8082111561492a578384fd5b61493688838901614515565b9450604087015191508082111561494b578384fd5b61495788838901614515565b9350606087015191508082111561496c578283fd5b5061497987828801614515565b91505092959194509250565b60008060408385031215614997578182fd5b82356149a281615dc1565b9150602083013567ffffffffffffffff8111156149bd578182fd5b6149c9858286016142fa565b9150509250929050565b600080600080608085870312156149e8578182fd5b84356149f381615dc1565b9350602085013567ffffffffffffffff80821115614a0f578384fd5b614a1b88838901614469565b94506040870135915080821115614a30578384fd5b614a3c88838901614469565b93506060870135915080821115614a51578283fd5b50614979878288016144c7565b60008060408385031215614a70578182fd5b8235614a7b81615dc1565b9150602083013567ffffffffffffffff811115614a96578182fd5b6149c9858286016144c7565b600080600060608486031215614ab6578081fd5b8335614ac181615dc1565b9250602084013567ffffffffffffffff811115614adc578182fd5b614ae8868287016144c7565b925050604084013590509250925092565b60008060408385031215614b0b578182fd5b8235614b1681615dc1565b946020939093013593505050565b600060208284031215614b35578081fd5b813567ffffffffffffffff811115614b4b578182fd5b613e8484828501614229565b600060208284031215614b68578081fd5b815167ffffffffffffffff811115614b7e578182fd5b613e8484828501614355565b600080600060608486031215614b9e578081fd5b833567ffffffffffffffff80821115614bb5578283fd5b614bc1878388016143b0565b94506020860135915080821115614bd6578283fd5b614be287838801614229565b93506040860135915080821115614bf7578283fd5b50614c0486828701614469565b9150509250925092565b60008060408385031215614c20578182fd5b823567ffffffffffffffff80821115614c37578384fd5b614c43868387016143b0565b93506020850135915080821115614c58578283fd5b506149c9858286016142fa565b600080600060608486031215614c79578081fd5b835167ffffffffffffffff80821115614c90578283fd5b614c9c87838801614355565b94506020860151915080821115614cb1578283fd5b614cbd8783880161440b565b93506040860151915080821115614cd2578283fd5b50614c0486828701614295565b600080600060608486031215614cf3578081fd5b835167ffffffffffffffff80821115614d0a578283fd5b614d1687838801614355565b9450602086015193506040860151915080821115614cd2578283fd5b60008060408385031215614d44578182fd5b823567ffffffffffffffff80821115614d5b578384fd5b614c4386838701614469565b60008060408385031215614d79578182fd5b825167ffffffffffffffff80821115614d90578384fd5b614d9c8683870161440b565b93506020850151915080821115614db1578283fd5b506149c985828601614295565b600060208284031215614dcf578081fd5b81518015158114610dc1578182fd5b60008060008060808587031215614df3578182fd5b845193506020850151614e0581615dc1565b604086015190935067ffffffffffffffff8082111561494b578384fd5b60008060408385031215614e34578182fd5b505080516020909101519092909150565b60008060408385031215614e57578182fd5b82519150602083015167ffffffffffffffff811115614e74578182fd5b6149c985828601614515565b600080600060608486031215614e94578081fd5b83519250602084015167ffffffffffffffff80821115614eb2578283fd5b614ebe87838801614515565b93506040860151915080821115614ed3578283fd5b50614c0486828701614515565b60008060408385031215614ef2578182fd5b82519150602083015161484881615dd6565b60008060408385031215614f16578182fd5b82516001600160e01b031981168114614837578283fd5b600060208284031215614f3e578081fd5b813567ffffffffffffffff811115614f54578182fd5b613e84848285016144c7565b60006060828403128015614f72578182fd5b8015614f7c578182fd5b50614f876060615cfb565b614f9184846147ed565b815260208301516020820152604083015160408201528091505092915050565b600060208284031215614fc2578081fd5b815167ffffffffffffffff811115614fd8578182fd5b613e84848285016146aa565b600080600060608486031215614ff8578081fd5b833567ffffffffffffffff81111561500e578182fd5b61501a8682870161455b565b935050602084013561502b81615dc1565b929592945050506040919091013590565b6000806040838503121561504e578182fd5b823567ffffffffffffffff80821115615065578384fd5b6150718683870161455b565b93506020850135915080821115615086578283fd5b506149c9858286016144c7565b600080600080608085870312156150a8578182fd5b845167ffffffffffffffff808211156150bf578384fd5b6150cb888389016146aa565b955060208701519150808211156150e0578384fd5b614936888389016146aa565b600080600060608486031215615100578081fd5b835167ffffffffffffffff80821115615117578283fd5b615123878388016146aa565b9450602086015193506040860151915080821115614ed3578283fd5b600060208284031215615150578081fd5b5051919050565b60008060408385031215615169578182fd5b825161517481615dd6565b6020939093015192949293505050565b600080600060608486031215615198578081fd5b83516151a381615dd6565b6020850151604086015191945092506151bb81615dc1565b809150509250925092565b600080600080608085870312156151db578182fd5b6151e586866147ed565b93506020850151925060408501516151fc81615dc1565b606086015190925067ffffffffffffffff811115615218578182fd5b61497987828801614515565b600080600060608486031215615238578081fd5b61524285856147ed565b925060208401519150604084015167ffffffffffffffff811115615264578182fd5b614c0486828701614515565b600080600060608486031215615284578081fd5b61528e85856147ed565b925060208401519150604084015190509250925092565b6001600160a01b03169052565b6000815180845260208401935060208301825b828110156152ec5781516001600160a01b03168652602095860195909101906001016152c5565b5093949350505050565b600081518084526020840180819550602083028101915060208501845b8481101561534157828403885261532b84835161537e565b6020988901989094509190910190600101615313565b50919695505050505050565b6000815180845260208401935060208301825b828110156152ec578151865260209586019590910190600101615360565b60008151808452615396816020860160208601615d66565b601f01601f19169290920160200192915050565b805160ff16825260208082015190830152604090810151910152565b60006101c06153d68484516152a5565b60208301516153e860208601826152a5565b5060408301516153fb60408601826152a5565b50606083015161540e60608601826152a5565b506080830151608085015260a083015160a085015260c083015160c085015260e083015160e08501526101008084015181860152506101208084015181860152506101408084015182828701526154678387018261537e565b91505061016091508184015185820383870152615484828261537e565b9250505061018080840151858303828701526154a0838261537e565b9150506101a0915081840151858203838701526154bd828261537e565b9695505050505050565b600082516154d9818460208701615d66565b9190910192915050565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b60006001600160a01b038616825260806020830152615557608083018661534d565b8281036040840152615569818661534d565b838103606085015261557b818661537e565b98975050505050505050565b60006001600160a01b0385168252606060208301526155a9606083018561537e565b9050826040830152949350505050565b60006001600160a01b0386168252608060208301526155db608083018661537e565b8281036040840152615569818661537e565b6001600160a01b03929092168252602082015260400190565b60006080825261561960808301876152f6565b828103602084015261562b81876152b2565b838103604085015261563d81876152b2565b9150508281036060840152615652818561534d565b979650505050505050565b602080825282518282018190526000918401906040840190835b8181101561569e57835161568a81615db7565b835260209384019390920191600101615677565b509095945050505050565b606080825284519082018190526000906020906080840190828801845b828110156156ec576156d98483516153aa565b60609390930192908401906001016156c6565b50505083810382850152615700818761534d565b84810360408601528551808252908301915082860190845b81811015615736578251151584529284019291840191600101615718565b509198975050505050505050565b600060208252610dc1602083018461534d565b60006040825261576a604083018561534d565b828103602084015261577c81856152f6565b95945050505050565b600060408252615798604083018561534d565b828103602084015261577c818561534d565b60008582526001600160a01b0385166020830152608060408301526157d2608083018561537e565b8281036060840152615652818561537e565b918252602082015260400190565b600083825260406020830152613e84604083018461537e565b600084825260606020830152615824606083018561537e565b82810360408401526154bd818561537e565b8281526040810161584683615dad565b8260208301529392505050565b6001600160e01b031991909116815260200190565b6001600160e01b03199290921682526001600160a01b0316602082015260400190565b60006001600160e01b0319871682526001600160a01b038616602083015260a060408301526158bd60a083018661534d565b82810360608401526158cf818661534d565b83810360808501526158e1818661537e565b9998505050505050505050565b60006001600160e01b0319861682526001600160a01b038516602083015260806040830152615920608083018561537e565b905082606083015295945050505050565b6001600160e01b03199390931683526001600160a01b03919091166020830152604082015260600190565b60006001600160e01b0319851682526060602083015261597f606083018561534d565b82810360408401526154bd81856152f6565b600060208252610dc1602083018461537e565b6000608082526159b7608083018761537e565b6001600160a01b03958616602084015293909416604082015260ff9190911660609091015292915050565b60006159ed85615d96565b8482528360208301526060604083015261577c606083018461537e565b6060810160048510615a1857fe5b938152602081019290925260409091015290565b60608101615a3985615da3565b93815260208101929092526001600160a01b031660409091015290565b6040810160048410615a6457fe5b9281526020015290565b60608101615a1885615da3565b6060810160088510615a1857fe5b60208101615a9683615db7565b91905290565b6000615aa786615dad565b8582528460208301526001600160a01b0384166040830152608060608301526154bd608083018461537e565b60408101615a6484615d96565b600060808252615af3608083018761537e565b602083820381850152818751808452828401915082838202850101838a01865b83811015615b4157601f19878403018552615b2f8383516153c6565b94860194925090850190600101615b13565b50508681036040880152615b55818a61534d565b945050505050828103606084015261565281856152f6565b60208082526013908201527f554e4b4e4f574e5f52455455524e5f4441544100000000000000000000000000604082015260600190565b60208082526019908201527f554e4b4e4f574e5f46554e4354494f4e5f53454c4543544f5200000000000000604082015260600190565b6020808252600d908201527f554e494d504c454d454e54454400000000000000000000000000000000000000604082015260600190565b6020808252600c908201527f4241445f53454c4543544f520000000000000000000000000000000000000000604082015260600190565b6020808252600e908201527f57524f4e475f50524f58595f4944000000000000000000000000000000000000604082015260600190565b60a08101615c8e82866153aa565b8360608301528215156080830152949350505050565b600060208252610dc160208301846153c6565b600060408252615cca60408301856153c6565b828103602084015261577c818561537e565b90815260200190565b9283526020830191909152604082015260600190565b60405181810167ffffffffffffffff81118282101715615d1a57600080fd5b604052919050565b600067ffffffffffffffff821115615d38578081fd5b5060209081020190565b600067ffffffffffffffff821115615d58578081fd5b50601f01601f191660200190565b60005b83811015615d81578181015183820152602001615d69565b83811115615d90576000848401525b50505050565b60028110615da057fe5b50565b60038110615da057fe5b60078110615da057fe5b60058110615da057fe5b6001600160a01b0381168114615da057600080fd5b60ff81168114615da057600080fdfea365627a7a723158209bd08114ba2e3dada6fb089e11dba7dc3bfedf454a0bac82e7a05d67b08360dd6c6578706572696d656e74616cf564736f6c634300050c0040';
    /**
     * Decompose an ABI-encoded AssetProxyDispatchError.
     */
    public decodeAssetProxyDispatchError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns errorCode The error code.orderHash Hash of the order being dispatched.assetData Asset data of the order being dispatched.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[number, string, string]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeAssetProxyDispatchError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeAssetProxyDispatchError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[number, string, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded AssetProxyExistsError.
     */
    public decodeAssetProxyExistsError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns assetProxyId Id of asset proxy.assetProxyAddress The address of the asset proxy.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, string]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeAssetProxyExistsError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeAssetProxyExistsError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decode AssetProxy identifier
     */
    public decodeAssetProxyId = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param assetData AssetProxy-compliant asset data describing an ERC-20, ERC-
         *     721, ERC1155, or MultiAsset asset.
         * @returns The AssetProxy identifier
         */
        async callAsync(
            assetData: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<string> {
            assert.isString('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeAssetProxyId(bytes)', [assetData]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeAssetProxyId(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<string>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded AssetProxyTransferError.
     */
    public decodeAssetProxyTransferError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns orderHash Hash of the order being dispatched.assetData Asset data of the order being dispatched.errorData ABI-encoded revert data from the asset proxy.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, string, string]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeAssetProxyTransferError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeAssetProxyTransferError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, string, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded SignatureValidatorError.
     */
    public decodeEIP1271SignatureError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns signerAddress The expected signer of the hash.signature The full signature bytes.errorData The revert data thrown by the validator contract.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, string, string, string]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeEIP1271SignatureError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeEIP1271SignatureError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, string, string, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decode ERC-1155 asset data from the format described in the AssetProxy contract specification.
     */
    public decodeERC1155AssetData = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param assetData AssetProxy-compliant asset data describing an ERC-1155 set
         *     of assets.
         * @returns The ERC-1155 AssetProxy identifier, the address of the ERC-1155 contract hosting the assets, an array of the identifiers of the assets to be traded, an array of asset amounts to be traded, and callback data.  Each element of the arrays corresponds to the same-indexed element of the other array.  Return values specified as &#x60;memory&#x60; are returned as pointers to locations within the memory of the input parameter &#x60;assetData&#x60;.
         */
        async callAsync(
            assetData: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, string, BigNumber[], BigNumber[], string]> {
            assert.isString('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeERC1155AssetData(bytes)', [assetData]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeERC1155AssetData(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, string, BigNumber[], BigNumber[], string]>(
                rawCallResult,
            );
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decode ERC-20 asset data from the format described in the AssetProxy contract specification.
     */
    public decodeERC20AssetData = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param assetData AssetProxy-compliant asset data describing an ERC-20 asset.
         * @returns The AssetProxy identifier, and the address of the ERC-20  contract hosting this asset.
         */
        async callAsync(
            assetData: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, string]> {
            assert.isString('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeERC20AssetData(bytes)', [assetData]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeERC20AssetData(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decode ERC-721 asset data from the format described in the AssetProxy contract specification.
     */
    public decodeERC721AssetData = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param assetData AssetProxy-compliant asset data describing an ERC-721
         *     asset.
         * @returns The ERC-721 AssetProxy identifier, the address of the ERC-721 contract hosting this asset, and the identifier of the specific asset to be traded.
         */
        async callAsync(
            assetData: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, string, BigNumber]> {
            assert.isString('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeERC721AssetData(bytes)', [assetData]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeERC721AssetData(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, string, BigNumber]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded OrderStatusError.
     */
    public decodeExchangeInvalidContextError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns errorCode Error code that corresponds to invalid maker, taker, or sender.orderHash The order hash.contextAddress The maker, taker, or sender address
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[number, string, string]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeExchangeInvalidContextError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeExchangeInvalidContextError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[number, string, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded FillError.
     */
    public decodeFillError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns errorCode The error code.orderHash The order hash.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[number, string]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeFillError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeFillError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[number, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded IncompleteFillError.
     */
    public decodeIncompleteFillError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns orderHash Hash of the order being filled.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[number, BigNumber, BigNumber]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeIncompleteFillError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeIncompleteFillError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[number, BigNumber, BigNumber]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decode multi-asset data from the format described in the AssetProxy contract specification.
     */
    public decodeMultiAssetData = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param assetData AssetProxy-compliant data describing a multi-asset basket.
         * @returns The Multi-Asset AssetProxy identifier, an array of the amounts of the assets to be traded, and an array of the AssetProxy-compliant data describing each asset to be traded.  Each element of the arrays corresponds to the same-indexed element of the other array.
         */
        async callAsync(
            assetData: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, BigNumber[], string[]]> {
            assert.isString('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeMultiAssetData(bytes)', [assetData]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeMultiAssetData(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, BigNumber[], string[]]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded NegativeSpreadError.
     */
    public decodeNegativeSpreadError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns leftOrderHash Hash of the left order being matched.rightOrderHash Hash of the right order being matched.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, string]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeNegativeSpreadError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeNegativeSpreadError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded OrderEpochError.
     */
    public decodeOrderEpochError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns makerAddress The order maker.orderSenderAddress The order sender.currentEpoch The current epoch for the maker.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, string, BigNumber]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeOrderEpochError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeOrderEpochError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, string, BigNumber]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded OrderStatusError.
     */
    public decodeOrderStatusError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns orderHash The order hash.orderStatus The order status.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, number]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeOrderStatusError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeOrderStatusError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, number]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded SignatureError.
     */
    public decodeSignatureError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns errorCode The error code.signerAddress The expected signer of the hash.signature The full signature.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[number, string, string, string]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeSignatureError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeSignatureError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[number, string, string, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded SignatureValidatorNotApprovedError.
     */
    public decodeSignatureValidatorNotApprovedError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns signerAddress The expected signer of the hash.validatorAddress The expected validator.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, string]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeSignatureValidatorNotApprovedError(bytes)', [
                encoded,
            ]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeSignatureValidatorNotApprovedError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded SignatureWalletError.
     */
    public decodeSignatureWalletError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns errorCode The error code.signerAddress The expected signer of the hash.signature The full signature bytes.errorData The revert data thrown by the validator contract.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, string, string, string]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeSignatureWalletError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeSignatureWalletError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, string, string, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decode StaticCall asset data from the format described in the AssetProxy contract specification.
     */
    public decodeStaticCallAssetData = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param assetData AssetProxy-compliant asset data describing a StaticCall
         *     asset
         * @returns The StaticCall AssetProxy identifier, the target address of the StaticCAll, the data to be passed to the target address, and the expected Keccak-256 hash of the static call return data.
         */
        async callAsync(
            assetData: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, string, string, string]> {
            assert.isString('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeStaticCallAssetData(bytes)', [assetData]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeStaticCallAssetData(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, string, string, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded TransactionError.
     */
    public decodeTransactionError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns errorCode The error code.transactionHash Hash of the transaction.
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[number, string]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeTransactionError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeTransactionError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[number, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decompose an ABI-encoded TransactionExecutionError.
     */
    public decodeTransactionExecutionError = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param encoded ABI-encoded revert error.
         * @returns transactionHash Hash of the transaction.errorData Error thrown by exeucteTransaction().
         */
        async callAsync(
            encoded: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[string, string]> {
            assert.isString('encoded', encoded);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeTransactionExecutionError(bytes)', [encoded]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeTransactionExecutionError(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[string, string]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Decodes the call data for an Exchange contract method call.
     */
    public decodeZeroExTransactionData = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param transactionData ABI-encoded calldata for an Exchange     contract
         *     method call.
         * @returns The name of the function called, and the parameters it was     given.  For single-order fills and cancels, the arrays will have     just one element.
         */
        async callAsync(
            transactionData: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<
            [
                string,
                Array<{
                    makerAddress: string;
                    takerAddress: string;
                    feeRecipientAddress: string;
                    senderAddress: string;
                    makerAssetAmount: BigNumber;
                    takerAssetAmount: BigNumber;
                    makerFee: BigNumber;
                    takerFee: BigNumber;
                    expirationTimeSeconds: BigNumber;
                    salt: BigNumber;
                    makerAssetData: string;
                    takerAssetData: string;
                    makerFeeAssetData: string;
                    takerFeeAssetData: string;
                }>,
                BigNumber[],
                string[]
            ]
        > {
            assert.isString('transactionData', transactionData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('decodeZeroExTransactionData(bytes)', [transactionData]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('decodeZeroExTransactionData(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<
                [
                    string,
                    Array<{
                        makerAddress: string;
                        takerAddress: string;
                        feeRecipientAddress: string;
                        senderAddress: string;
                        makerAssetAmount: BigNumber;
                        takerAssetAmount: BigNumber;
                        makerFee: BigNumber;
                        takerFee: BigNumber;
                        expirationTimeSeconds: BigNumber;
                        salt: BigNumber;
                        makerAssetData: string;
                        takerAssetData: string;
                        makerFeeAssetData: string;
                        takerFeeAssetData: string;
                    }>,
                    BigNumber[],
                    string[]
                ]
            >(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Encode ERC-1155 asset data into the format described in the AssetProxy contract specification.
     */
    public encodeERC1155AssetData = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param tokenAddress The address of the ERC-1155 contract hosting the
         *     asset(s) to be traded.
         * @param tokenIds The identifiers of the specific assets to be traded.
         * @param tokenValues The amounts of each asset to be traded.
         * @param callbackData Data to be passed to receiving contracts when a transfer
         *     is performed.
         * @returns AssetProxy-compliant asset data describing the set of assets.
         */
        async callAsync(
            tokenAddress: string,
            tokenIds: BigNumber[],
            tokenValues: BigNumber[],
            callbackData: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<string> {
            assert.isString('tokenAddress', tokenAddress);
            assert.isArray('tokenIds', tokenIds);
            assert.isArray('tokenValues', tokenValues);
            assert.isString('callbackData', callbackData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments(
                'encodeERC1155AssetData(address,uint256[],uint256[],bytes)',
                [tokenAddress.toLowerCase(), tokenIds, tokenValues, callbackData],
            );
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('encodeERC1155AssetData(address,uint256[],uint256[],bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<string>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Encode ERC-20 asset data into the format described in the AssetProxy contract specification.
     */
    public encodeERC20AssetData = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param tokenAddress The address of the ERC-20 contract hosting the asset to
         *     be traded.
         * @returns AssetProxy-compliant data describing the asset.
         */
        async callAsync(
            tokenAddress: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<string> {
            assert.isString('tokenAddress', tokenAddress);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('encodeERC20AssetData(address)', [
                tokenAddress.toLowerCase(),
            ]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('encodeERC20AssetData(address)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<string>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Encode ERC-721 asset data into the format described in the AssetProxy specification.
     */
    public encodeERC721AssetData = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param tokenAddress The address of the ERC-721 contract hosting the asset to
         *     be traded.
         * @param tokenId The identifier of the specific asset to be traded.
         * @returns AssetProxy-compliant asset data describing the asset.
         */
        async callAsync(
            tokenAddress: string,
            tokenId: BigNumber,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<string> {
            assert.isString('tokenAddress', tokenAddress);
            assert.isBigNumber('tokenId', tokenId);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('encodeERC721AssetData(address,uint256)', [
                tokenAddress.toLowerCase(),
                tokenId,
            ]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('encodeERC721AssetData(address,uint256)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<string>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Encode data for multiple assets, per the AssetProxy contract specification.
     */
    public encodeMultiAssetData = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param amounts The amounts of each asset to be traded.
         * @param nestedAssetData AssetProxy-compliant data describing each asset to be
         *     traded.
         * @returns AssetProxy-compliant data describing the set of assets.
         */
        async callAsync(
            amounts: BigNumber[],
            nestedAssetData: string[],
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<string> {
            assert.isArray('amounts', amounts);
            assert.isArray('nestedAssetData', nestedAssetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('encodeMultiAssetData(uint256[],bytes[])', [
                amounts,
                nestedAssetData,
            ]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('encodeMultiAssetData(uint256[],bytes[])');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<string>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Encode StaticCall asset data into the format described in the AssetProxy contract specification.
     */
    public encodeStaticCallAssetData = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param staticCallTargetAddress Target address of StaticCall.
         * @param staticCallData Data that will be passed to staticCallTargetAddress in
         *     the StaticCall.
         * @param expectedReturnDataHash Expected Keccak-256 hash of the StaticCall
         *     return data.
         * @returns AssetProxy-compliant asset data describing the set of assets.
         */
        async callAsync(
            staticCallTargetAddress: string,
            staticCallData: string,
            expectedReturnDataHash: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<string> {
            assert.isString('staticCallTargetAddress', staticCallTargetAddress);
            assert.isString('staticCallData', staticCallData);
            assert.isString('expectedReturnDataHash', expectedReturnDataHash);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('encodeStaticCallAssetData(address,bytes,bytes32)', [
                staticCallTargetAddress.toLowerCase(),
                staticCallData,
                expectedReturnDataHash,
            ]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('encodeStaticCallAssetData(address,bytes,bytes32)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<string>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Returns the number of asset(s) (described by assetData) that the corresponding AssetProxy contract is authorized to spend.  When the asset data contains multiple assets (eg for Multi-Asset), the return value indicates how many complete "baskets" of those assets may be spent by all of the corresponding AssetProxy contracts.
     */
    public getAssetProxyAllowance = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param ownerAddress Owner of the assets specified by assetData.
         * @param assetData Details of asset, encoded per the AssetProxy contract
         *     specification.
         * @returns Number of assets (or asset baskets) that the corresponding AssetProxy is authorized to spend.
         */
        async callAsync(
            ownerAddress: string,
            assetData: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<BigNumber> {
            assert.isString('ownerAddress', ownerAddress);
            assert.isString('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('getAssetProxyAllowance(address,bytes)', [
                ownerAddress.toLowerCase(),
                assetData,
            ]);
            const callDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...callData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            callDataWithDefaults.from = callDataWithDefaults.from
                ? callDataWithDefaults.from.toLowerCase()
                : callDataWithDefaults.from;
            let rawCallResult;
            try {
                rawCallResult = await self._web3Wrapper.callAsync(callDataWithDefaults, defaultBlock);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);
            const abiEncoder = self._lookupAbiEncoder('getAssetProxyAllowance(address,bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<BigNumber>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Returns the owner's balance of the assets(s) specified in assetData.  When the asset data contains multiple assets (eg in ERC1155 or Multi-Asset), the return value indicates how many complete "baskets" of those assets are owned by owner.
     */
    public getBalance = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param ownerAddress Owner of the assets specified by assetData.
         * @param assetData Details of asset, encoded per the AssetProxy contract
         *     specification.
         * @returns Number of assets (or asset baskets) held by owner.
         */
        async callAsync(
            ownerAddress: string,
            assetData: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<BigNumber> {
            assert.isString('ownerAddress', ownerAddress);
            assert.isString('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('getBalance(address,bytes)', [
                ownerAddress.toLowerCase(),
                assetData,
            ]);
            const callDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...callData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            callDataWithDefaults.from = callDataWithDefaults.from
                ? callDataWithDefaults.from.toLowerCase()
                : callDataWithDefaults.from;
            let rawCallResult;
            try {
                rawCallResult = await self._web3Wrapper.callAsync(callDataWithDefaults, defaultBlock);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);
            const abiEncoder = self._lookupAbiEncoder('getBalance(address,bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<BigNumber>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Calls getBalance() and getAllowance() for assetData.
     */
    public getBalanceAndAssetProxyAllowance = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param ownerAddress Owner of the assets specified by assetData.
         * @param assetData Details of asset, encoded per the AssetProxy contract
         *     specification.
         * @returns Number of assets (or asset baskets) held by owner, and number of assets (or asset baskets) that the corresponding AssetProxy is authorized to spend.
         */
        async callAsync(
            ownerAddress: string,
            assetData: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[BigNumber, BigNumber]> {
            assert.isString('ownerAddress', ownerAddress);
            assert.isString('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('getBalanceAndAssetProxyAllowance(address,bytes)', [
                ownerAddress.toLowerCase(),
                assetData,
            ]);
            const callDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...callData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            callDataWithDefaults.from = callDataWithDefaults.from
                ? callDataWithDefaults.from.toLowerCase()
                : callDataWithDefaults.from;
            let rawCallResult;
            try {
                rawCallResult = await self._web3Wrapper.callAsync(callDataWithDefaults, defaultBlock);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);
            const abiEncoder = self._lookupAbiEncoder('getBalanceAndAssetProxyAllowance(address,bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[BigNumber, BigNumber]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Calls getAssetProxyAllowance() for each element of assetData.
     */
    public getBatchAssetProxyAllowances = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param ownerAddress Owner of the assets specified by assetData.
         * @param assetData Array of asset details, each encoded per the AssetProxy
         *     contract specification.
         * @returns An array of asset allowances from getAllowance(), with each element corresponding to the same-indexed element in the assetData input.
         */
        async callAsync(
            ownerAddress: string,
            assetData: string[],
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<BigNumber[]> {
            assert.isString('ownerAddress', ownerAddress);
            assert.isArray('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('getBatchAssetProxyAllowances(address,bytes[])', [
                ownerAddress.toLowerCase(),
                assetData,
            ]);
            const callDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...callData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            callDataWithDefaults.from = callDataWithDefaults.from
                ? callDataWithDefaults.from.toLowerCase()
                : callDataWithDefaults.from;
            let rawCallResult;
            try {
                rawCallResult = await self._web3Wrapper.callAsync(callDataWithDefaults, defaultBlock);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);
            const abiEncoder = self._lookupAbiEncoder('getBatchAssetProxyAllowances(address,bytes[])');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<BigNumber[]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Calls getBalance() for each element of assetData.
     */
    public getBatchBalances = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param ownerAddress Owner of the assets specified by assetData.
         * @param assetData Array of asset details, each encoded per the AssetProxy
         *     contract specification.
         * @returns Array of asset balances from getBalance(), with each element corresponding to the same-indexed element in the assetData input.
         */
        async callAsync(
            ownerAddress: string,
            assetData: string[],
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<BigNumber[]> {
            assert.isString('ownerAddress', ownerAddress);
            assert.isArray('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('getBatchBalances(address,bytes[])', [
                ownerAddress.toLowerCase(),
                assetData,
            ]);
            const callDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...callData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            callDataWithDefaults.from = callDataWithDefaults.from
                ? callDataWithDefaults.from.toLowerCase()
                : callDataWithDefaults.from;
            let rawCallResult;
            try {
                rawCallResult = await self._web3Wrapper.callAsync(callDataWithDefaults, defaultBlock);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);
            const abiEncoder = self._lookupAbiEncoder('getBatchBalances(address,bytes[])');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<BigNumber[]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Calls getBatchBalances() and getBatchAllowances() for each element of assetData.
     */
    public getBatchBalancesAndAssetProxyAllowances = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param ownerAddress Owner of the assets specified by assetData.
         * @param assetData Array of asset details, each encoded per the AssetProxy
         *     contract specification.
         * @returns An array of asset balances from getBalance(), and an array of asset allowances from getAllowance(), with each element corresponding to the same-indexed element in the assetData input.
         */
        async callAsync(
            ownerAddress: string,
            assetData: string[],
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<[BigNumber[], BigNumber[]]> {
            assert.isString('ownerAddress', ownerAddress);
            assert.isArray('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments(
                'getBatchBalancesAndAssetProxyAllowances(address,bytes[])',
                [ownerAddress.toLowerCase(), assetData],
            );
            const callDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...callData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            callDataWithDefaults.from = callDataWithDefaults.from
                ? callDataWithDefaults.from.toLowerCase()
                : callDataWithDefaults.from;
            let rawCallResult;
            try {
                rawCallResult = await self._web3Wrapper.callAsync(callDataWithDefaults, defaultBlock);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);
            const abiEncoder = self._lookupAbiEncoder('getBatchBalancesAndAssetProxyAllowances(address,bytes[])');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<[BigNumber[], BigNumber[]]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Batch fetches ETH balances
     */
    public getEthBalances = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param addresses Array of addresses.
         * @returns Array of ETH balances.
         */
        async callAsync(
            addresses: string[],
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<BigNumber[]> {
            assert.isArray('addresses', addresses);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('getEthBalances(address[])', [addresses]);
            const callDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...callData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            callDataWithDefaults.from = callDataWithDefaults.from
                ? callDataWithDefaults.from.toLowerCase()
                : callDataWithDefaults.from;
            let rawCallResult;
            try {
                rawCallResult = await self._web3Wrapper.callAsync(callDataWithDefaults, defaultBlock);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);
            const abiEncoder = self._lookupAbiEncoder('getEthBalances(address[])');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<BigNumber[]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Fetches all order-relevant information needed to validate if the supplied order is fillable.
     */
    public getOrderRelevantState = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param order The order structure.
         * @param signature Signature provided by maker that proves the order's
         *     authenticity. `0x01` can always be provided if the signature does not
         *     need to be validated.
         * @returns The orderInfo (hash, status, and &#x60;takerAssetAmount&#x60; already filled for the given order), fillableTakerAssetAmount (amount of the order&#x27;s &#x60;takerAssetAmount&#x60; that is fillable given all on-chain state), and isValidSignature (validity of the provided signature). NOTE: If the &#x60;takerAssetData&#x60; encodes data for multiple assets, &#x60;fillableTakerAssetAmount&#x60; will represent a &quot;scaled&quot; amount, meaning it must be multiplied by all the individual asset amounts within the &#x60;takerAssetData&#x60; to get the final amount of each asset that can be filled.
         */
        async callAsync(
            order: {
                makerAddress: string;
                takerAddress: string;
                feeRecipientAddress: string;
                senderAddress: string;
                makerAssetAmount: BigNumber;
                takerAssetAmount: BigNumber;
                makerFee: BigNumber;
                takerFee: BigNumber;
                expirationTimeSeconds: BigNumber;
                salt: BigNumber;
                makerAssetData: string;
                takerAssetData: string;
                makerFeeAssetData: string;
                takerFeeAssetData: string;
            },
            signature: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<
            [{ orderStatus: number; orderHash: string; orderTakerAssetFilledAmount: BigNumber }, BigNumber, boolean]
        > {
            assert.isString('signature', signature);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments(
                'getOrderRelevantState((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes),bytes)',
                [order, signature],
            );
            const callDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...callData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            callDataWithDefaults.from = callDataWithDefaults.from
                ? callDataWithDefaults.from.toLowerCase()
                : callDataWithDefaults.from;
            let rawCallResult;
            try {
                rawCallResult = await self._web3Wrapper.callAsync(callDataWithDefaults, defaultBlock);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);
            const abiEncoder = self._lookupAbiEncoder(
                'getOrderRelevantState((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes),bytes)',
            );
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<
                [{ orderStatus: number; orderHash: string; orderTakerAssetFilledAmount: BigNumber }, BigNumber, boolean]
            >(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Fetches all order-relevant information needed to validate if the supplied orders are fillable.
     */
    public getOrderRelevantStates = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param orders Array of order structures.
         * @param signatures Array of signatures provided by makers that prove the
         *     authenticity of the orders. `0x01` can always be provided if a signature
         *     does not need to be validated.
         * @returns The ordersInfo (array of the hash, status, and &#x60;takerAssetAmount&#x60; already filled for each order), fillableTakerAssetAmounts (array of amounts for each order&#x27;s &#x60;takerAssetAmount&#x60; that is fillable given all on-chain state), and isValidSignature (array containing the validity of each provided signature). NOTE: If the &#x60;takerAssetData&#x60; encodes data for multiple assets, each element of &#x60;fillableTakerAssetAmounts&#x60; will represent a &quot;scaled&quot; amount, meaning it must be multiplied by all the individual asset amounts within the &#x60;takerAssetData&#x60; to get the final amount of each asset that can be filled.
         */
        async callAsync(
            orders: Array<{
                makerAddress: string;
                takerAddress: string;
                feeRecipientAddress: string;
                senderAddress: string;
                makerAssetAmount: BigNumber;
                takerAssetAmount: BigNumber;
                makerFee: BigNumber;
                takerFee: BigNumber;
                expirationTimeSeconds: BigNumber;
                salt: BigNumber;
                makerAssetData: string;
                takerAssetData: string;
                makerFeeAssetData: string;
                takerFeeAssetData: string;
            }>,
            signatures: string[],
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<
            [
                Array<{ orderStatus: number; orderHash: string; orderTakerAssetFilledAmount: BigNumber }>,
                BigNumber[],
                boolean[]
            ]
        > {
            assert.isArray('orders', orders);
            assert.isArray('signatures', signatures);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments(
                'getOrderRelevantStates((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes)[],bytes[])',
                [orders, signatures],
            );
            const callDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...callData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            callDataWithDefaults.from = callDataWithDefaults.from
                ? callDataWithDefaults.from.toLowerCase()
                : callDataWithDefaults.from;
            let rawCallResult;
            try {
                rawCallResult = await self._web3Wrapper.callAsync(callDataWithDefaults, defaultBlock);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);
            const abiEncoder = self._lookupAbiEncoder(
                'getOrderRelevantStates((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes)[],bytes[])',
            );
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<
                [
                    Array<{ orderStatus: number; orderHash: string; orderTakerAssetFilledAmount: BigNumber }>,
                    BigNumber[],
                    boolean[]
                ]
            >(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    /**
     * Simulates all of the transfers within an order and returns the index of the first failed transfer.
     */
    public getSimulatedOrderTransferResults = {
        /**
         * Sends an Ethereum transaction executing this method with the supplied parameters. This is a read/write
         * Ethereum operation and will cost gas.
         * @param order The order to simulate transfers for.
         * @param takerAddress The address of the taker that will fill the order.
         * @param takerAssetFillAmount The amount of takerAsset that the taker wished
         *     to fill.
         * @param txData Additional data for transaction
         * @returns The hash of the transaction
         */
        async sendTransactionAsync(
            order: {
                makerAddress: string;
                takerAddress: string;
                feeRecipientAddress: string;
                senderAddress: string;
                makerAssetAmount: BigNumber;
                takerAssetAmount: BigNumber;
                makerFee: BigNumber;
                takerFee: BigNumber;
                expirationTimeSeconds: BigNumber;
                salt: BigNumber;
                makerAssetData: string;
                takerAssetData: string;
                makerFeeAssetData: string;
                takerFeeAssetData: string;
            },
            takerAddress: string,
            takerAssetFillAmount: BigNumber,
            txData?: Partial<TxData> | undefined,
            opts: SendTransactionOpts = { shouldValidate: true },
        ): Promise<string> {
            assert.isString('takerAddress', takerAddress);
            assert.isBigNumber('takerAssetFillAmount', takerAssetFillAmount);
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments(
                'getSimulatedOrderTransferResults((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes),address,uint256)',
                [order, takerAddress.toLowerCase(), takerAssetFillAmount],
            );
            const txDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...txData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            if (txDataWithDefaults.from !== undefined) {
                txDataWithDefaults.from = txDataWithDefaults.from.toLowerCase();
            }

            if (opts.shouldValidate !== false) {
                await self.getSimulatedOrderTransferResults.callAsync(
                    order,
                    takerAddress,
                    takerAssetFillAmount,
                    txDataWithDefaults,
                );
            }

            const txHash = await self._web3Wrapper.sendTransactionAsync(txDataWithDefaults);
            return txHash;
        },
        /**
         * Sends an Ethereum transaction and waits until the transaction has been successfully mined without reverting.
         * If the transaction was mined, but reverted, an error is thrown.
         * @param order The order to simulate transfers for.
         * @param takerAddress The address of the taker that will fill the order.
         * @param takerAssetFillAmount The amount of takerAsset that the taker wished
         *     to fill.
         * @param txData Additional data for transaction
         * @param pollingIntervalMs Interval at which to poll for success
         * @returns A promise that resolves when the transaction is successful
         */
        awaitTransactionSuccessAsync(
            order: {
                makerAddress: string;
                takerAddress: string;
                feeRecipientAddress: string;
                senderAddress: string;
                makerAssetAmount: BigNumber;
                takerAssetAmount: BigNumber;
                makerFee: BigNumber;
                takerFee: BigNumber;
                expirationTimeSeconds: BigNumber;
                salt: BigNumber;
                makerAssetData: string;
                takerAssetData: string;
                makerFeeAssetData: string;
                takerFeeAssetData: string;
            },
            takerAddress: string,
            takerAssetFillAmount: BigNumber,
            txData?: Partial<TxData>,
            opts: AwaitTransactionSuccessOpts = { shouldValidate: true },
        ): PromiseWithTransactionHash<TransactionReceiptWithDecodedLogs> {
            assert.isString('takerAddress', takerAddress);
            assert.isBigNumber('takerAssetFillAmount', takerAssetFillAmount);
            const self = (this as any) as DevUtilsContract;
            const txHashPromise = self.getSimulatedOrderTransferResults.sendTransactionAsync(
                order,
                takerAddress.toLowerCase(),
                takerAssetFillAmount,
                txData,
                opts,
            );
            return new PromiseWithTransactionHash<TransactionReceiptWithDecodedLogs>(
                txHashPromise,
                (async (): Promise<TransactionReceiptWithDecodedLogs> => {
                    // When the transaction hash resolves, wait for it to be mined.
                    return self._web3Wrapper.awaitTransactionSuccessAsync(
                        await txHashPromise,
                        opts.pollingIntervalMs,
                        opts.timeoutMs,
                    );
                })(),
            );
        },
        /**
         * Estimates the gas cost of sending an Ethereum transaction calling this method with these arguments.
         * @param order The order to simulate transfers for.
         * @param takerAddress The address of the taker that will fill the order.
         * @param takerAssetFillAmount The amount of takerAsset that the taker wished
         *     to fill.
         * @param txData Additional data for transaction
         * @returns The hash of the transaction
         */
        async estimateGasAsync(
            order: {
                makerAddress: string;
                takerAddress: string;
                feeRecipientAddress: string;
                senderAddress: string;
                makerAssetAmount: BigNumber;
                takerAssetAmount: BigNumber;
                makerFee: BigNumber;
                takerFee: BigNumber;
                expirationTimeSeconds: BigNumber;
                salt: BigNumber;
                makerAssetData: string;
                takerAssetData: string;
                makerFeeAssetData: string;
                takerFeeAssetData: string;
            },
            takerAddress: string,
            takerAssetFillAmount: BigNumber,
            txData?: Partial<TxData> | undefined,
        ): Promise<number> {
            assert.isString('takerAddress', takerAddress);
            assert.isBigNumber('takerAssetFillAmount', takerAssetFillAmount);
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments(
                'getSimulatedOrderTransferResults((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes),address,uint256)',
                [order, takerAddress.toLowerCase(), takerAssetFillAmount],
            );
            const txDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...txData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            if (txDataWithDefaults.from !== undefined) {
                txDataWithDefaults.from = txDataWithDefaults.from.toLowerCase();
            }

            const gas = await self._web3Wrapper.estimateGasAsync(txDataWithDefaults);
            return gas;
        },
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param order The order to simulate transfers for.
         * @param takerAddress The address of the taker that will fill the order.
         * @param takerAssetFillAmount The amount of takerAsset that the taker wished
         *     to fill.
         * @returns The index of the first failed transfer (or 4 if all transfers are successful).
         */
        async callAsync(
            order: {
                makerAddress: string;
                takerAddress: string;
                feeRecipientAddress: string;
                senderAddress: string;
                makerAssetAmount: BigNumber;
                takerAssetAmount: BigNumber;
                makerFee: BigNumber;
                takerFee: BigNumber;
                expirationTimeSeconds: BigNumber;
                salt: BigNumber;
                makerAssetData: string;
                takerAssetData: string;
                makerFeeAssetData: string;
                takerFeeAssetData: string;
            },
            takerAddress: string,
            takerAssetFillAmount: BigNumber,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<number> {
            assert.isString('takerAddress', takerAddress);
            assert.isBigNumber('takerAssetFillAmount', takerAssetFillAmount);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments(
                'getSimulatedOrderTransferResults((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes),address,uint256)',
                [order, takerAddress.toLowerCase(), takerAssetFillAmount],
            );
            const callDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...callData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            callDataWithDefaults.from = callDataWithDefaults.from
                ? callDataWithDefaults.from.toLowerCase()
                : callDataWithDefaults.from;
            let rawCallResult;
            try {
                rawCallResult = await self._web3Wrapper.callAsync(callDataWithDefaults, defaultBlock);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);
            const abiEncoder = self._lookupAbiEncoder(
                'getSimulatedOrderTransferResults((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes),address,uint256)',
            );
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<number>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
        /**
         * Returns the ABI encoded transaction data needed to send an Ethereum transaction calling this method. Before
         * sending the Ethereum tx, this encoded tx data can first be sent to a separate signing service or can be used
         * to create a 0x transaction (see protocol spec for more details).
         * @param order The order to simulate transfers for.
         * @param takerAddress The address of the taker that will fill the order.
         * @param takerAssetFillAmount The amount of takerAsset that the taker wished
         *     to fill.
         * @returns The ABI encoded transaction data as a string
         */
        getABIEncodedTransactionData(
            order: {
                makerAddress: string;
                takerAddress: string;
                feeRecipientAddress: string;
                senderAddress: string;
                makerAssetAmount: BigNumber;
                takerAssetAmount: BigNumber;
                makerFee: BigNumber;
                takerFee: BigNumber;
                expirationTimeSeconds: BigNumber;
                salt: BigNumber;
                makerAssetData: string;
                takerAssetData: string;
                makerFeeAssetData: string;
                takerFeeAssetData: string;
            },
            takerAddress: string,
            takerAssetFillAmount: BigNumber,
        ): string {
            assert.isString('takerAddress', takerAddress);
            assert.isBigNumber('takerAssetFillAmount', takerAssetFillAmount);
            const self = (this as any) as DevUtilsContract;
            const abiEncodedTransactionData = self._strictEncodeArguments(
                'getSimulatedOrderTransferResults((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes),address,uint256)',
                [order, takerAddress.toLowerCase(), takerAssetFillAmount],
            );
            return abiEncodedTransactionData;
        },
        /**
         * Returns the 4 byte function selector as a hex string.
         */
        getSelector(): string {
            const self = (this as any) as DevUtilsContract;
            const abiEncoder = self._lookupAbiEncoder(
                'getSimulatedOrderTransferResults((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes),address,uint256)',
            );
            return abiEncoder.getSelector();
        },
    };
    /**
     * Simulates all of the transfers for each given order and returns the indices of each first failed transfer.
     */
    public getSimulatedOrdersTransferResults = {
        /**
         * Sends an Ethereum transaction executing this method with the supplied parameters. This is a read/write
         * Ethereum operation and will cost gas.
         * @param orders Array of orders to individually simulate transfers for.
         * @param takerAddresses Array of addresses of takers that will fill each
         *     order.
         * @param takerAssetFillAmounts Array of amounts of takerAsset that will be
         *     filled for each order.
         * @param txData Additional data for transaction
         * @returns The hash of the transaction
         */
        async sendTransactionAsync(
            orders: Array<{
                makerAddress: string;
                takerAddress: string;
                feeRecipientAddress: string;
                senderAddress: string;
                makerAssetAmount: BigNumber;
                takerAssetAmount: BigNumber;
                makerFee: BigNumber;
                takerFee: BigNumber;
                expirationTimeSeconds: BigNumber;
                salt: BigNumber;
                makerAssetData: string;
                takerAssetData: string;
                makerFeeAssetData: string;
                takerFeeAssetData: string;
            }>,
            takerAddresses: string[],
            takerAssetFillAmounts: BigNumber[],
            txData?: Partial<TxData> | undefined,
            opts: SendTransactionOpts = { shouldValidate: true },
        ): Promise<string> {
            assert.isArray('orders', orders);
            assert.isArray('takerAddresses', takerAddresses);
            assert.isArray('takerAssetFillAmounts', takerAssetFillAmounts);
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments(
                'getSimulatedOrdersTransferResults((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes)[],address[],uint256[])',
                [orders, takerAddresses, takerAssetFillAmounts],
            );
            const txDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...txData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            if (txDataWithDefaults.from !== undefined) {
                txDataWithDefaults.from = txDataWithDefaults.from.toLowerCase();
            }

            if (opts.shouldValidate !== false) {
                await self.getSimulatedOrdersTransferResults.callAsync(
                    orders,
                    takerAddresses,
                    takerAssetFillAmounts,
                    txDataWithDefaults,
                );
            }

            const txHash = await self._web3Wrapper.sendTransactionAsync(txDataWithDefaults);
            return txHash;
        },
        /**
         * Sends an Ethereum transaction and waits until the transaction has been successfully mined without reverting.
         * If the transaction was mined, but reverted, an error is thrown.
         * @param orders Array of orders to individually simulate transfers for.
         * @param takerAddresses Array of addresses of takers that will fill each
         *     order.
         * @param takerAssetFillAmounts Array of amounts of takerAsset that will be
         *     filled for each order.
         * @param txData Additional data for transaction
         * @param pollingIntervalMs Interval at which to poll for success
         * @returns A promise that resolves when the transaction is successful
         */
        awaitTransactionSuccessAsync(
            orders: Array<{
                makerAddress: string;
                takerAddress: string;
                feeRecipientAddress: string;
                senderAddress: string;
                makerAssetAmount: BigNumber;
                takerAssetAmount: BigNumber;
                makerFee: BigNumber;
                takerFee: BigNumber;
                expirationTimeSeconds: BigNumber;
                salt: BigNumber;
                makerAssetData: string;
                takerAssetData: string;
                makerFeeAssetData: string;
                takerFeeAssetData: string;
            }>,
            takerAddresses: string[],
            takerAssetFillAmounts: BigNumber[],
            txData?: Partial<TxData>,
            opts: AwaitTransactionSuccessOpts = { shouldValidate: true },
        ): PromiseWithTransactionHash<TransactionReceiptWithDecodedLogs> {
            assert.isArray('orders', orders);
            assert.isArray('takerAddresses', takerAddresses);
            assert.isArray('takerAssetFillAmounts', takerAssetFillAmounts);
            const self = (this as any) as DevUtilsContract;
            const txHashPromise = self.getSimulatedOrdersTransferResults.sendTransactionAsync(
                orders,
                takerAddresses,
                takerAssetFillAmounts,
                txData,
                opts,
            );
            return new PromiseWithTransactionHash<TransactionReceiptWithDecodedLogs>(
                txHashPromise,
                (async (): Promise<TransactionReceiptWithDecodedLogs> => {
                    // When the transaction hash resolves, wait for it to be mined.
                    return self._web3Wrapper.awaitTransactionSuccessAsync(
                        await txHashPromise,
                        opts.pollingIntervalMs,
                        opts.timeoutMs,
                    );
                })(),
            );
        },
        /**
         * Estimates the gas cost of sending an Ethereum transaction calling this method with these arguments.
         * @param orders Array of orders to individually simulate transfers for.
         * @param takerAddresses Array of addresses of takers that will fill each
         *     order.
         * @param takerAssetFillAmounts Array of amounts of takerAsset that will be
         *     filled for each order.
         * @param txData Additional data for transaction
         * @returns The hash of the transaction
         */
        async estimateGasAsync(
            orders: Array<{
                makerAddress: string;
                takerAddress: string;
                feeRecipientAddress: string;
                senderAddress: string;
                makerAssetAmount: BigNumber;
                takerAssetAmount: BigNumber;
                makerFee: BigNumber;
                takerFee: BigNumber;
                expirationTimeSeconds: BigNumber;
                salt: BigNumber;
                makerAssetData: string;
                takerAssetData: string;
                makerFeeAssetData: string;
                takerFeeAssetData: string;
            }>,
            takerAddresses: string[],
            takerAssetFillAmounts: BigNumber[],
            txData?: Partial<TxData> | undefined,
        ): Promise<number> {
            assert.isArray('orders', orders);
            assert.isArray('takerAddresses', takerAddresses);
            assert.isArray('takerAssetFillAmounts', takerAssetFillAmounts);
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments(
                'getSimulatedOrdersTransferResults((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes)[],address[],uint256[])',
                [orders, takerAddresses, takerAssetFillAmounts],
            );
            const txDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...txData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            if (txDataWithDefaults.from !== undefined) {
                txDataWithDefaults.from = txDataWithDefaults.from.toLowerCase();
            }

            const gas = await self._web3Wrapper.estimateGasAsync(txDataWithDefaults);
            return gas;
        },
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param orders Array of orders to individually simulate transfers for.
         * @param takerAddresses Array of addresses of takers that will fill each
         *     order.
         * @param takerAssetFillAmounts Array of amounts of takerAsset that will be
         *     filled for each order.
         * @returns The indices of the first failed transfer (or 4 if all transfers are successful) for each order.
         */
        async callAsync(
            orders: Array<{
                makerAddress: string;
                takerAddress: string;
                feeRecipientAddress: string;
                senderAddress: string;
                makerAssetAmount: BigNumber;
                takerAssetAmount: BigNumber;
                makerFee: BigNumber;
                takerFee: BigNumber;
                expirationTimeSeconds: BigNumber;
                salt: BigNumber;
                makerAssetData: string;
                takerAssetData: string;
                makerFeeAssetData: string;
                takerFeeAssetData: string;
            }>,
            takerAddresses: string[],
            takerAssetFillAmounts: BigNumber[],
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<number[]> {
            assert.isArray('orders', orders);
            assert.isArray('takerAddresses', takerAddresses);
            assert.isArray('takerAssetFillAmounts', takerAssetFillAmounts);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments(
                'getSimulatedOrdersTransferResults((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes)[],address[],uint256[])',
                [orders, takerAddresses, takerAssetFillAmounts],
            );
            const callDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...callData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            callDataWithDefaults.from = callDataWithDefaults.from
                ? callDataWithDefaults.from.toLowerCase()
                : callDataWithDefaults.from;
            let rawCallResult;
            try {
                rawCallResult = await self._web3Wrapper.callAsync(callDataWithDefaults, defaultBlock);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);
            const abiEncoder = self._lookupAbiEncoder(
                'getSimulatedOrdersTransferResults((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes)[],address[],uint256[])',
            );
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<number[]>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
        /**
         * Returns the ABI encoded transaction data needed to send an Ethereum transaction calling this method. Before
         * sending the Ethereum tx, this encoded tx data can first be sent to a separate signing service or can be used
         * to create a 0x transaction (see protocol spec for more details).
         * @param orders Array of orders to individually simulate transfers for.
         * @param takerAddresses Array of addresses of takers that will fill each
         *     order.
         * @param takerAssetFillAmounts Array of amounts of takerAsset that will be
         *     filled for each order.
         * @returns The ABI encoded transaction data as a string
         */
        getABIEncodedTransactionData(
            orders: Array<{
                makerAddress: string;
                takerAddress: string;
                feeRecipientAddress: string;
                senderAddress: string;
                makerAssetAmount: BigNumber;
                takerAssetAmount: BigNumber;
                makerFee: BigNumber;
                takerFee: BigNumber;
                expirationTimeSeconds: BigNumber;
                salt: BigNumber;
                makerAssetData: string;
                takerAssetData: string;
                makerFeeAssetData: string;
                takerFeeAssetData: string;
            }>,
            takerAddresses: string[],
            takerAssetFillAmounts: BigNumber[],
        ): string {
            assert.isArray('orders', orders);
            assert.isArray('takerAddresses', takerAddresses);
            assert.isArray('takerAssetFillAmounts', takerAssetFillAmounts);
            const self = (this as any) as DevUtilsContract;
            const abiEncodedTransactionData = self._strictEncodeArguments(
                'getSimulatedOrdersTransferResults((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes)[],address[],uint256[])',
                [orders, takerAddresses, takerAssetFillAmounts],
            );
            return abiEncodedTransactionData;
        },
        /**
         * Returns the 4 byte function selector as a hex string.
         */
        getSelector(): string {
            const self = (this as any) as DevUtilsContract;
            const abiEncoder = self._lookupAbiEncoder(
                'getSimulatedOrdersTransferResults((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes)[],address[],uint256[])',
            );
            return abiEncoder.getSelector();
        },
    };
    /**
     * Gets the amount of an asset transferable by the owner.
     */
    public getTransferableAssetAmount = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         * @param ownerAddress Address of the owner of the asset.
         * @param assetData Description of tokens, per the AssetProxy contract
         *     specification.
         * @returns The amount of the asset tranferable by the owner. NOTE: If the &#x60;assetData&#x60; encodes data for multiple assets, the &#x60;transferableAssetAmount&#x60; will represent the amount of times the entire &#x60;assetData&#x60; can be transferred. To calculate the total individual transferable amounts, this scaled &#x60;transferableAmount&#x60; must be multiplied by the individual asset amounts located within the &#x60;assetData&#x60;.
         */
        async callAsync(
            ownerAddress: string,
            assetData: string,
            callData: Partial<CallData> = {},
            defaultBlock?: BlockParam,
        ): Promise<BigNumber> {
            assert.isString('ownerAddress', ownerAddress);
            assert.isString('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('getTransferableAssetAmount(address,bytes)', [
                ownerAddress.toLowerCase(),
                assetData,
            ]);
            const callDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
                {
                    to: self.address,
                    ...callData,
                    data: encodedData,
                },
                self._web3Wrapper.getContractDefaults(),
            );
            callDataWithDefaults.from = callDataWithDefaults.from
                ? callDataWithDefaults.from.toLowerCase()
                : callDataWithDefaults.from;
            let rawCallResult;
            try {
                rawCallResult = await self._web3Wrapper.callAsync(callDataWithDefaults, defaultBlock);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);
            const abiEncoder = self._lookupAbiEncoder('getTransferableAssetAmount(address,bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<BigNumber>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    public revertIfInvalidAssetData = {
        /**
         * Sends a read-only call to the contract method. Returns the result that would happen if one were to send an
         * Ethereum transaction to this method, given the current state of the blockchain. Calls do not cost gas
         * since they don't modify state.
         */
        async callAsync(assetData: string, callData: Partial<CallData> = {}, defaultBlock?: BlockParam): Promise<void> {
            assert.isString('assetData', assetData);
            assert.doesConformToSchema('callData', callData, schemas.callDataSchema, [
                schemas.addressSchema,
                schemas.numberSchema,
                schemas.jsNumber,
            ]);
            if (defaultBlock !== undefined) {
                assert.isBlockParam('defaultBlock', defaultBlock);
            }
            const self = (this as any) as DevUtilsContract;
            const encodedData = self._strictEncodeArguments('revertIfInvalidAssetData(bytes)', [assetData]);
            const encodedDataBytes = Buffer.from(encodedData.substr(2), 'hex');

            let rawCallResult;
            try {
                rawCallResult = await self._evmExecAsync(encodedDataBytes);
            } catch (err) {
                BaseContract._throwIfThrownErrorIsRevertError(err);
                throw err;
            }
            BaseContract._throwIfCallResultIsRevertError(rawCallResult);

            const abiEncoder = self._lookupAbiEncoder('revertIfInvalidAssetData(bytes)');
            // tslint:disable boolean-naming
            const result = abiEncoder.strictDecodeReturnValue<void>(rawCallResult);
            // tslint:enable boolean-naming
            return result;
        },
    };
    public static async deployFrom0xArtifactAsync(
        artifact: ContractArtifact | SimpleContractArtifact,
        supportedProvider: SupportedProvider,
        txDefaults: Partial<TxData>,
        logDecodeDependencies: { [contractName: string]: ContractArtifact | SimpleContractArtifact },
        _exchange: string,
    ): Promise<DevUtilsContract> {
        assert.doesConformToSchema('txDefaults', txDefaults, schemas.txDataSchema, [
            schemas.addressSchema,
            schemas.numberSchema,
            schemas.jsNumber,
        ]);
        if (artifact.compilerOutput === undefined) {
            throw new Error('Compiler output not found in the artifact file');
        }
        const provider = providerUtils.standardizeOrThrow(supportedProvider);
        const bytecode = artifact.compilerOutput.evm.bytecode.object;
        const abi = artifact.compilerOutput.abi;
        const logDecodeDependenciesAbiOnly: { [contractName: string]: ContractAbi } = {};
        if (Object.keys(logDecodeDependencies) !== undefined) {
            for (const key of Object.keys(logDecodeDependencies)) {
                logDecodeDependenciesAbiOnly[key] = logDecodeDependencies[key].compilerOutput.abi;
            }
        }
        return DevUtilsContract.deployAsync(
            bytecode,
            abi,
            provider,
            txDefaults,
            logDecodeDependenciesAbiOnly,
            _exchange,
        );
    }
    public static async deployAsync(
        bytecode: string,
        abi: ContractAbi,
        supportedProvider: SupportedProvider,
        txDefaults: Partial<TxData>,
        logDecodeDependencies: { [contractName: string]: ContractAbi },
        _exchange: string,
    ): Promise<DevUtilsContract> {
        assert.isHexString('bytecode', bytecode);
        assert.doesConformToSchema('txDefaults', txDefaults, schemas.txDataSchema, [
            schemas.addressSchema,
            schemas.numberSchema,
            schemas.jsNumber,
        ]);
        const provider = providerUtils.standardizeOrThrow(supportedProvider);
        const constructorAbi = BaseContract._lookupConstructorAbi(abi);
        [_exchange] = BaseContract._formatABIDataItemList(
            constructorAbi.inputs,
            [_exchange],
            BaseContract._bigNumberToString,
        );
        const iface = new ethers.utils.Interface(abi);
        const deployInfo = iface.deployFunction;
        const txData = deployInfo.encode(bytecode, [_exchange]);
        const web3Wrapper = new Web3Wrapper(provider);
        const txDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
            { data: txData },
            txDefaults,
            web3Wrapper.estimateGasAsync.bind(web3Wrapper),
        );
        const txHash = await web3Wrapper.sendTransactionAsync(txDataWithDefaults);
        logUtils.log(`transactionHash: ${txHash}`);
        const txReceipt = await web3Wrapper.awaitTransactionSuccessAsync(txHash);
        logUtils.log(`DevUtils successfully deployed at ${txReceipt.contractAddress}`);
        const contractInstance = new DevUtilsContract(
            txReceipt.contractAddress as string,
            provider,
            txDefaults,
            logDecodeDependencies,
        );
        contractInstance.constructorArgs = [_exchange];
        return contractInstance;
    }

    /**
     * @returns      The contract ABI
     */
    public static ABI(): ContractAbi {
        const abi = [
            {
                inputs: [
                    {
                        name: '_exchange',
                        type: 'address',
                    },
                ],
                outputs: [],
                payable: false,
                stateMutability: 'nonpayable',
                type: 'constructor',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeAssetProxyDispatchError',
                outputs: [
                    {
                        name: 'errorCode',
                        type: 'uint8',
                    },
                    {
                        name: 'orderHash',
                        type: 'bytes32',
                    },
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeAssetProxyExistsError',
                outputs: [
                    {
                        name: 'assetProxyId',
                        type: 'bytes4',
                    },
                    {
                        name: 'assetProxyAddress',
                        type: 'address',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                name: 'decodeAssetProxyId',
                outputs: [
                    {
                        name: 'assetProxyId',
                        type: 'bytes4',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeAssetProxyTransferError',
                outputs: [
                    {
                        name: 'orderHash',
                        type: 'bytes32',
                    },
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                    {
                        name: 'errorData',
                        type: 'bytes',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeEIP1271SignatureError',
                outputs: [
                    {
                        name: 'verifyingContractAddress',
                        type: 'address',
                    },
                    {
                        name: 'data',
                        type: 'bytes',
                    },
                    {
                        name: 'signature',
                        type: 'bytes',
                    },
                    {
                        name: 'errorData',
                        type: 'bytes',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                name: 'decodeERC1155AssetData',
                outputs: [
                    {
                        name: 'assetProxyId',
                        type: 'bytes4',
                    },
                    {
                        name: 'tokenAddress',
                        type: 'address',
                    },
                    {
                        name: 'tokenIds',
                        type: 'uint256[]',
                    },
                    {
                        name: 'tokenValues',
                        type: 'uint256[]',
                    },
                    {
                        name: 'callbackData',
                        type: 'bytes',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                name: 'decodeERC20AssetData',
                outputs: [
                    {
                        name: 'assetProxyId',
                        type: 'bytes4',
                    },
                    {
                        name: 'tokenAddress',
                        type: 'address',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                name: 'decodeERC721AssetData',
                outputs: [
                    {
                        name: 'assetProxyId',
                        type: 'bytes4',
                    },
                    {
                        name: 'tokenAddress',
                        type: 'address',
                    },
                    {
                        name: 'tokenId',
                        type: 'uint256',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeExchangeInvalidContextError',
                outputs: [
                    {
                        name: 'errorCode',
                        type: 'uint8',
                    },
                    {
                        name: 'orderHash',
                        type: 'bytes32',
                    },
                    {
                        name: 'contextAddress',
                        type: 'address',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeFillError',
                outputs: [
                    {
                        name: 'errorCode',
                        type: 'uint8',
                    },
                    {
                        name: 'orderHash',
                        type: 'bytes32',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeIncompleteFillError',
                outputs: [
                    {
                        name: 'errorCode',
                        type: 'uint8',
                    },
                    {
                        name: 'expectedAssetFillAmount',
                        type: 'uint256',
                    },
                    {
                        name: 'actualAssetFillAmount',
                        type: 'uint256',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                name: 'decodeMultiAssetData',
                outputs: [
                    {
                        name: 'assetProxyId',
                        type: 'bytes4',
                    },
                    {
                        name: 'amounts',
                        type: 'uint256[]',
                    },
                    {
                        name: 'nestedAssetData',
                        type: 'bytes[]',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeNegativeSpreadError',
                outputs: [
                    {
                        name: 'leftOrderHash',
                        type: 'bytes32',
                    },
                    {
                        name: 'rightOrderHash',
                        type: 'bytes32',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeOrderEpochError',
                outputs: [
                    {
                        name: 'makerAddress',
                        type: 'address',
                    },
                    {
                        name: 'orderSenderAddress',
                        type: 'address',
                    },
                    {
                        name: 'currentEpoch',
                        type: 'uint256',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeOrderStatusError',
                outputs: [
                    {
                        name: 'orderHash',
                        type: 'bytes32',
                    },
                    {
                        name: 'orderStatus',
                        type: 'uint8',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeSignatureError',
                outputs: [
                    {
                        name: 'errorCode',
                        type: 'uint8',
                    },
                    {
                        name: 'hash',
                        type: 'bytes32',
                    },
                    {
                        name: 'signerAddress',
                        type: 'address',
                    },
                    {
                        name: 'signature',
                        type: 'bytes',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeSignatureValidatorNotApprovedError',
                outputs: [
                    {
                        name: 'signerAddress',
                        type: 'address',
                    },
                    {
                        name: 'validatorAddress',
                        type: 'address',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeSignatureWalletError',
                outputs: [
                    {
                        name: 'hash',
                        type: 'bytes32',
                    },
                    {
                        name: 'signerAddress',
                        type: 'address',
                    },
                    {
                        name: 'signature',
                        type: 'bytes',
                    },
                    {
                        name: 'errorData',
                        type: 'bytes',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                name: 'decodeStaticCallAssetData',
                outputs: [
                    {
                        name: 'assetProxyId',
                        type: 'bytes4',
                    },
                    {
                        name: 'staticCallTargetAddress',
                        type: 'address',
                    },
                    {
                        name: 'staticCallData',
                        type: 'bytes',
                    },
                    {
                        name: 'expectedReturnDataHash',
                        type: 'bytes32',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeTransactionError',
                outputs: [
                    {
                        name: 'errorCode',
                        type: 'uint8',
                    },
                    {
                        name: 'transactionHash',
                        type: 'bytes32',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'encoded',
                        type: 'bytes',
                    },
                ],
                name: 'decodeTransactionExecutionError',
                outputs: [
                    {
                        name: 'transactionHash',
                        type: 'bytes32',
                    },
                    {
                        name: 'errorData',
                        type: 'bytes',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'transactionData',
                        type: 'bytes',
                    },
                ],
                name: 'decodeZeroExTransactionData',
                outputs: [
                    {
                        name: 'functionName',
                        type: 'string',
                    },
                    {
                        name: 'orders',
                        type: 'tuple[]',
                        components: [
                            {
                                name: 'makerAddress',
                                type: 'address',
                            },
                            {
                                name: 'takerAddress',
                                type: 'address',
                            },
                            {
                                name: 'feeRecipientAddress',
                                type: 'address',
                            },
                            {
                                name: 'senderAddress',
                                type: 'address',
                            },
                            {
                                name: 'makerAssetAmount',
                                type: 'uint256',
                            },
                            {
                                name: 'takerAssetAmount',
                                type: 'uint256',
                            },
                            {
                                name: 'makerFee',
                                type: 'uint256',
                            },
                            {
                                name: 'takerFee',
                                type: 'uint256',
                            },
                            {
                                name: 'expirationTimeSeconds',
                                type: 'uint256',
                            },
                            {
                                name: 'salt',
                                type: 'uint256',
                            },
                            {
                                name: 'makerAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'takerAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'makerFeeAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'takerFeeAssetData',
                                type: 'bytes',
                            },
                        ],
                    },
                    {
                        name: 'takerAssetFillAmounts',
                        type: 'uint256[]',
                    },
                    {
                        name: 'signatures',
                        type: 'bytes[]',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'tokenAddress',
                        type: 'address',
                    },
                    {
                        name: 'tokenIds',
                        type: 'uint256[]',
                    },
                    {
                        name: 'tokenValues',
                        type: 'uint256[]',
                    },
                    {
                        name: 'callbackData',
                        type: 'bytes',
                    },
                ],
                name: 'encodeERC1155AssetData',
                outputs: [
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'tokenAddress',
                        type: 'address',
                    },
                ],
                name: 'encodeERC20AssetData',
                outputs: [
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'tokenAddress',
                        type: 'address',
                    },
                    {
                        name: 'tokenId',
                        type: 'uint256',
                    },
                ],
                name: 'encodeERC721AssetData',
                outputs: [
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'amounts',
                        type: 'uint256[]',
                    },
                    {
                        name: 'nestedAssetData',
                        type: 'bytes[]',
                    },
                ],
                name: 'encodeMultiAssetData',
                outputs: [
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'staticCallTargetAddress',
                        type: 'address',
                    },
                    {
                        name: 'staticCallData',
                        type: 'bytes',
                    },
                    {
                        name: 'expectedReturnDataHash',
                        type: 'bytes32',
                    },
                ],
                name: 'encodeStaticCallAssetData',
                outputs: [
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'ownerAddress',
                        type: 'address',
                    },
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                name: 'getAssetProxyAllowance',
                outputs: [
                    {
                        name: 'allowance',
                        type: 'uint256',
                    },
                ],
                payable: false,
                stateMutability: 'view',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'ownerAddress',
                        type: 'address',
                    },
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                name: 'getBalance',
                outputs: [
                    {
                        name: 'balance',
                        type: 'uint256',
                    },
                ],
                payable: false,
                stateMutability: 'view',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'ownerAddress',
                        type: 'address',
                    },
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                name: 'getBalanceAndAssetProxyAllowance',
                outputs: [
                    {
                        name: 'balance',
                        type: 'uint256',
                    },
                    {
                        name: 'allowance',
                        type: 'uint256',
                    },
                ],
                payable: false,
                stateMutability: 'view',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'ownerAddress',
                        type: 'address',
                    },
                    {
                        name: 'assetData',
                        type: 'bytes[]',
                    },
                ],
                name: 'getBatchAssetProxyAllowances',
                outputs: [
                    {
                        name: 'allowances',
                        type: 'uint256[]',
                    },
                ],
                payable: false,
                stateMutability: 'view',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'ownerAddress',
                        type: 'address',
                    },
                    {
                        name: 'assetData',
                        type: 'bytes[]',
                    },
                ],
                name: 'getBatchBalances',
                outputs: [
                    {
                        name: 'balances',
                        type: 'uint256[]',
                    },
                ],
                payable: false,
                stateMutability: 'view',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'ownerAddress',
                        type: 'address',
                    },
                    {
                        name: 'assetData',
                        type: 'bytes[]',
                    },
                ],
                name: 'getBatchBalancesAndAssetProxyAllowances',
                outputs: [
                    {
                        name: 'balances',
                        type: 'uint256[]',
                    },
                    {
                        name: 'allowances',
                        type: 'uint256[]',
                    },
                ],
                payable: false,
                stateMutability: 'view',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'addresses',
                        type: 'address[]',
                    },
                ],
                name: 'getEthBalances',
                outputs: [
                    {
                        name: '',
                        type: 'uint256[]',
                    },
                ],
                payable: false,
                stateMutability: 'view',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'order',
                        type: 'tuple',
                        components: [
                            {
                                name: 'makerAddress',
                                type: 'address',
                            },
                            {
                                name: 'takerAddress',
                                type: 'address',
                            },
                            {
                                name: 'feeRecipientAddress',
                                type: 'address',
                            },
                            {
                                name: 'senderAddress',
                                type: 'address',
                            },
                            {
                                name: 'makerAssetAmount',
                                type: 'uint256',
                            },
                            {
                                name: 'takerAssetAmount',
                                type: 'uint256',
                            },
                            {
                                name: 'makerFee',
                                type: 'uint256',
                            },
                            {
                                name: 'takerFee',
                                type: 'uint256',
                            },
                            {
                                name: 'expirationTimeSeconds',
                                type: 'uint256',
                            },
                            {
                                name: 'salt',
                                type: 'uint256',
                            },
                            {
                                name: 'makerAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'takerAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'makerFeeAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'takerFeeAssetData',
                                type: 'bytes',
                            },
                        ],
                    },
                    {
                        name: 'signature',
                        type: 'bytes',
                    },
                ],
                name: 'getOrderRelevantState',
                outputs: [
                    {
                        name: 'orderInfo',
                        type: 'tuple',
                        components: [
                            {
                                name: 'orderStatus',
                                type: 'uint8',
                            },
                            {
                                name: 'orderHash',
                                type: 'bytes32',
                            },
                            {
                                name: 'orderTakerAssetFilledAmount',
                                type: 'uint256',
                            },
                        ],
                    },
                    {
                        name: 'fillableTakerAssetAmount',
                        type: 'uint256',
                    },
                    {
                        name: 'isValidSignature',
                        type: 'bool',
                    },
                ],
                payable: false,
                stateMutability: 'view',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'orders',
                        type: 'tuple[]',
                        components: [
                            {
                                name: 'makerAddress',
                                type: 'address',
                            },
                            {
                                name: 'takerAddress',
                                type: 'address',
                            },
                            {
                                name: 'feeRecipientAddress',
                                type: 'address',
                            },
                            {
                                name: 'senderAddress',
                                type: 'address',
                            },
                            {
                                name: 'makerAssetAmount',
                                type: 'uint256',
                            },
                            {
                                name: 'takerAssetAmount',
                                type: 'uint256',
                            },
                            {
                                name: 'makerFee',
                                type: 'uint256',
                            },
                            {
                                name: 'takerFee',
                                type: 'uint256',
                            },
                            {
                                name: 'expirationTimeSeconds',
                                type: 'uint256',
                            },
                            {
                                name: 'salt',
                                type: 'uint256',
                            },
                            {
                                name: 'makerAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'takerAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'makerFeeAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'takerFeeAssetData',
                                type: 'bytes',
                            },
                        ],
                    },
                    {
                        name: 'signatures',
                        type: 'bytes[]',
                    },
                ],
                name: 'getOrderRelevantStates',
                outputs: [
                    {
                        name: 'ordersInfo',
                        type: 'tuple[]',
                        components: [
                            {
                                name: 'orderStatus',
                                type: 'uint8',
                            },
                            {
                                name: 'orderHash',
                                type: 'bytes32',
                            },
                            {
                                name: 'orderTakerAssetFilledAmount',
                                type: 'uint256',
                            },
                        ],
                    },
                    {
                        name: 'fillableTakerAssetAmounts',
                        type: 'uint256[]',
                    },
                    {
                        name: 'isValidSignature',
                        type: 'bool[]',
                    },
                ],
                payable: false,
                stateMutability: 'view',
                type: 'function',
            },
            {
                constant: false,
                inputs: [
                    {
                        name: 'order',
                        type: 'tuple',
                        components: [
                            {
                                name: 'makerAddress',
                                type: 'address',
                            },
                            {
                                name: 'takerAddress',
                                type: 'address',
                            },
                            {
                                name: 'feeRecipientAddress',
                                type: 'address',
                            },
                            {
                                name: 'senderAddress',
                                type: 'address',
                            },
                            {
                                name: 'makerAssetAmount',
                                type: 'uint256',
                            },
                            {
                                name: 'takerAssetAmount',
                                type: 'uint256',
                            },
                            {
                                name: 'makerFee',
                                type: 'uint256',
                            },
                            {
                                name: 'takerFee',
                                type: 'uint256',
                            },
                            {
                                name: 'expirationTimeSeconds',
                                type: 'uint256',
                            },
                            {
                                name: 'salt',
                                type: 'uint256',
                            },
                            {
                                name: 'makerAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'takerAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'makerFeeAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'takerFeeAssetData',
                                type: 'bytes',
                            },
                        ],
                    },
                    {
                        name: 'takerAddress',
                        type: 'address',
                    },
                    {
                        name: 'takerAssetFillAmount',
                        type: 'uint256',
                    },
                ],
                name: 'getSimulatedOrderTransferResults',
                outputs: [
                    {
                        name: 'orderTransferResults',
                        type: 'uint8',
                    },
                ],
                payable: false,
                stateMutability: 'nonpayable',
                type: 'function',
            },
            {
                constant: false,
                inputs: [
                    {
                        name: 'orders',
                        type: 'tuple[]',
                        components: [
                            {
                                name: 'makerAddress',
                                type: 'address',
                            },
                            {
                                name: 'takerAddress',
                                type: 'address',
                            },
                            {
                                name: 'feeRecipientAddress',
                                type: 'address',
                            },
                            {
                                name: 'senderAddress',
                                type: 'address',
                            },
                            {
                                name: 'makerAssetAmount',
                                type: 'uint256',
                            },
                            {
                                name: 'takerAssetAmount',
                                type: 'uint256',
                            },
                            {
                                name: 'makerFee',
                                type: 'uint256',
                            },
                            {
                                name: 'takerFee',
                                type: 'uint256',
                            },
                            {
                                name: 'expirationTimeSeconds',
                                type: 'uint256',
                            },
                            {
                                name: 'salt',
                                type: 'uint256',
                            },
                            {
                                name: 'makerAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'takerAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'makerFeeAssetData',
                                type: 'bytes',
                            },
                            {
                                name: 'takerFeeAssetData',
                                type: 'bytes',
                            },
                        ],
                    },
                    {
                        name: 'takerAddresses',
                        type: 'address[]',
                    },
                    {
                        name: 'takerAssetFillAmounts',
                        type: 'uint256[]',
                    },
                ],
                name: 'getSimulatedOrdersTransferResults',
                outputs: [
                    {
                        name: 'orderTransferResults',
                        type: 'uint8[]',
                    },
                ],
                payable: false,
                stateMutability: 'nonpayable',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'ownerAddress',
                        type: 'address',
                    },
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                name: 'getTransferableAssetAmount',
                outputs: [
                    {
                        name: 'transferableAssetAmount',
                        type: 'uint256',
                    },
                ],
                payable: false,
                stateMutability: 'view',
                type: 'function',
            },
            {
                constant: true,
                inputs: [
                    {
                        name: 'assetData',
                        type: 'bytes',
                    },
                ],
                name: 'revertIfInvalidAssetData',
                outputs: [],
                payable: false,
                stateMutability: 'pure',
                type: 'function',
            },
        ] as ContractAbi;
        return abi;
    }
    constructor(
        address: string,
        supportedProvider: SupportedProvider,
        txDefaults?: Partial<TxData>,
        logDecodeDependencies?: { [contractName: string]: ContractAbi },
        deployedBytecode: string | undefined = DevUtilsContract.deployedBytecode,
    ) {
        super(
            'DevUtils',
            DevUtilsContract.ABI(),
            address,
            supportedProvider,
            txDefaults,
            logDecodeDependencies,
            deployedBytecode,
        );
        classUtils.bindAll(this, ['_abiEncoderByFunctionSignature', 'address', '_web3Wrapper']);
    }
}

// tslint:disable:max-file-line-count
// tslint:enable:no-unbound-method no-parameter-reassignment no-consecutive-blank-lines ordered-imports align
// tslint:enable:trailing-comma whitespace no-trailing-whitespace
