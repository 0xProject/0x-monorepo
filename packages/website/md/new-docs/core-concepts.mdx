## Introduction

0x is a protocol that facilitates the peer-to-peer exchange of Ethereum-based assets. The protocol serves as an open standard and common building block for any developer needing exchange functionality. Developers can integrate with 0x at the smart contract level, or on an application level, taking advantage of it’s audited, secure smart contracts, the many developer tools built for the 0x ecosystem and it’s shared liquidity pool.

## A conceptual overview of 0x

This section will give you a conceptual overview of 0x protocol. Future sections will give you the necessary Ethereum background to then dive into the technical details of the current implementation of 0x.

### The 0x order message format

At the core of 0x is a standard order message format. The order message format describes one party’s commmitment to trade assets at very specific terms with another party. By defining a standard message format for orders, 0x allows anyone who adheres to the standard to use 0x for settlement, and build their application using the many open-source tools designed to work with 0x orders.

A 0x order has the following fields:

| Parameter           | Description                                                                                                                                                                                                       |
| ------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| makerAddress        | Address that created the order. The maker is one of the two parties that will be involved in the trade if the order gets filled.                                                                                  |
| takerAddress        | Address that is allowed to fill the order. If set to 0, anyone is allowed to fill the order. This field allows makers to decide who can fill an order, rendering it useless to eavesdroppers or outside parties.  |
| feeRecipientAddress | The address that will receive the fees stipulated by the order. This is typically used to incentivize off-chain order relay.                                                                                      |
| makerAssetData      | `makerAssetData` makerAssetData contains all the identifying information about the asset the order maker is trying to sell. Since 0x supports arbitrary token standards, this value has a very specific encoding. |

The 0x order message format is rigid enough to enforce the necessary conditions the order maker requires to enter into a trade, and yet flexible enough to represent many different kinds of trades. Currently, 0x supports trading:

-   Fungible tokens (Those conforming to the ERC20 standard)

-   Non-fungible tokens (Those conforming to the ERC721 standard)

-   Bundles of assets (Trade one-to-many, many-to-one or many-to-many funglible & non-fungible assets with a single order)

And we are constantly adding support for new token standards and different ways to trade them due to the modular nature of 0x’s design. If you are curious about proposed additions to 0x protocol, browse through the ZEIPs (0x improvement proposals).

### Cryptography used by 0x protocol

Once an order maker has decided on all the details of the trade they wish to make, the last step is for them to cryptographically commit to the trade. 0x uses two fundamental building blocks of cryptography to make this happen. This section will introduce these building blocks and how 0x uses them.

#### Cryptographic hash function

A cryptographic hash function is a function that maps an input of arbitrary size to an output of fixed size (a hash). It is a one-way function meaning that it is infeasible to invert. The input data is typically called the message and the output the message digest. 0x uses a hash function to create an order digest (order hash) that uniquely identifies all the order fields chosen by the maker. Changing any of the fields of the order, will cause the order hash to change. Thanks to this property of hash functions, the order hash can be used as the unique identifier for an order. Another nice aspect of using a hash function is that all order hashes will have the same fixed length, regardless of the complexity or size of the order fields. We now have a unique, fixed-length identifier we can generate for every single permutation of a 0x order. The next step is to allow a maker to cryptographically commit to this representation of their 0x order.
