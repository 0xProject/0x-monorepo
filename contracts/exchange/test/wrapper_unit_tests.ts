import { ReferenceFunctions as LibReferenceFunctions } from '@0x/contracts-exchange-libs';
import {
    blockchainTests,
    constants,
    describe,
    expect,
    hexRandom,
    TransactionHelper,
} from '@0x/contracts-test-utils';
import { ReferenceFunctions as UtilReferenceFunctions } from '@0x/contracts-utils';
import { ExchangeRevertErrors } from '@0x/order-utils';
import { FillResults, OrderInfo, OrderStatus, OrderWithoutDomain as Order } from '@0x/types';
import {
    AnyRevertError,
    BigNumber,
    StringRevertError
} from '@0x/utils';
import { LogEntry, LogWithDecodedArgs } from 'ethereum-types';
import * as ethjs from 'ethereumjs-util';
import * as _ from 'lodash';

import {
    artifacts,
    TestWrapperFunctionsContract,
    TestWrapperFunctionsFillOrderCalledEventArgs as FillOrderCalledEventArgs,
    TestWrapperFunctionsCancelOrderCalledEventArgs as CancelOrderCalledEventArgs,
} from '../src';

blockchainTests.only('Exchange wrapper functions unit tests.', env => {
    const { ONE_ETHER } = constants;
    const { addFillResults, getPartialAmountFloor } = LibReferenceFunctions;
    const { safeSub } = UtilReferenceFunctions;
    const randomAddress = () => hexRandom(constants.ADDRESS_LENGTH);
    const randomAssetData = () => hexRandom(34);
    const randomSignature = () => `${hexRandom(32 * 3)}`;
    const randomAmount = (maxAmount: BigNumber = ONE_ETHER) => maxAmount.times(_.random(0, 100, true).toFixed(12));
    const randomTimestamp = () => new BigNumber(Math.floor(_.now() / 1000) + _.random(0, 34560));
    const randomSalt = () => new BigNumber(hexRandom(constants.WORD_LENGTH).substr(2), 16);
    const ALWAYS_FAILING_SALT = constants.MAX_UINT256;
    const ALWAYS_FAILING_SALT_REVERT_ERROR = new StringRevertError('ALWAYS_FAILING_SALT');
    const BAD_SIGNATURE_REVERT_REASON = new StringRevertError('BAD_SIGNATURE');
    const EMPTY_FILL_RESULTS = {
        makerAssetFilledAmount: constants.ZERO_AMOUNT,
        takerAssetFilledAmount: constants.ZERO_AMOUNT,
        makerFeePaid: constants.ZERO_AMOUNT,
        takerFeePaid: constants.ZERO_AMOUNT,
    };
    let testContract: TestWrapperFunctionsContract;
    let txHelper: TransactionHelper;
    let senderAddress: string;

    before(async () => {
        [ senderAddress ] = await env.getAccountAddressesAsync();
        txHelper = new TransactionHelper(env.web3Wrapper, artifacts);
        testContract = await TestWrapperFunctionsContract.deployFrom0xArtifactAsync(
            artifacts.TestWrapperFunctions,
            env.provider,
            env.txDefaults,
        );
    });

    function randomOrder(fields?: Partial<Order>): Order {
        return _.assign({
            makerAddress: randomAddress(),
            takerAddress: randomAddress(),
            feeRecipientAddress: randomAddress(),
            senderAddress: randomAddress(),
            takerAssetAmount: randomAmount(),
            makerAssetAmount: randomAmount(),
            makerFee: randomAmount(),
            takerFee: randomAmount(),
            expirationTimeSeconds: randomTimestamp(),
            salt: randomSalt(),
            makerAssetData: randomAssetData(),
            takerAssetData: randomAssetData(),
            makerFeeAssetData: randomAssetData(),
            takerFeeAssetData: randomAssetData(),
        }, fields);
    }

    // Computes the expected (fake) order hash generated by the `TestWrapperFunctions` contract.
    function getExpectedOrderHash(order: Order): string {
        return ethjs.bufferToHex(ethjs.sha3(Buffer.concat([
            ethjs.toBuffer(order.makerAssetData),
            ethjs.toBuffer(order.takerAssetData),
            ethjs.setLengthLeft(`0x${order.salt.toString(16)}`, constants.WORD_LENGTH),
        ])));
    }

    // Computes a valid signature for an order.
    function createOrderSignature(order: Order): string {
        return ethjs.bufferToHex(ethjs.sha3(ethjs.toBuffer(getExpectedOrderHash(order))));
    }

    // Computes the expected (fake) fill results from `TestWrapperFunctions` `_fillOrder` implementation.
    function getExpectedFillResults(order: Order, signature: string): FillResults {
        if (order.salt === ALWAYS_FAILING_SALT || signature !== createOrderSignature(order)) {
            return EMPTY_FILL_RESULTS;
        }
        return {
            makerAssetFilledAmount: order.makerAssetAmount,
            takerAssetFilledAmount: order.takerAssetAmount,
            makerFeePaid: order.makerFee,
            takerFeePaid: order.takerFee,
        };
    }

    // Asserts that `_fillOrder()` was called in the same order and with the same
    // arguments as given by examining receipt logs.
    function assertFillOrderCallsFromLogs(
        logs: LogEntry[],
        calls: Array<[Order, BigNumber, string]>,
    ): void {
        expect(logs.length).to.eq(calls.length);
        for (const i of _.times(calls.length)) {
            const log = logs[i] as LogWithDecodedArgs<FillOrderCalledEventArgs>;
            const [
                expectedOrder,
                expectedTakerAssetFillAmount,
                expectedSignature,
            ] = calls[i];
            expect(log.event).to.eq('FillOrderCalled');
            assertSameOrderFromEvent(log.args.order as any, expectedOrder);
            expect(log.args.takerAssetFillAmount).to.bignumber.eq(expectedTakerAssetFillAmount);
            expect(log.args.signature).to.eq(expectedSignature);
        }
    }

    function assertSameOrderFromEvent(actual: any[], expected: Order): void {
        expect(actual.length === 14);
        expect(actual[0].toLowerCase()).to.be.eq(expected.makerAddress);
        expect(actual[1].toLowerCase()).to.be.eq(expected.takerAddress);
        expect(actual[2].toLowerCase()).to.be.eq(expected.feeRecipientAddress);
        expect(actual[3].toLowerCase()).to.be.eq(expected.senderAddress);
        expect(actual[4]).to.be.bignumber.eq(expected.makerAssetAmount);
        expect(actual[5]).to.be.bignumber.eq(expected.takerAssetAmount);
        expect(actual[6]).to.be.bignumber.eq(expected.makerFee);
        expect(actual[7]).to.be.bignumber.eq(expected.takerFee);
        expect(actual[8]).to.be.bignumber.eq(expected.expirationTimeSeconds);
        expect(actual[9]).to.be.bignumber.eq(expected.salt);
        expect(actual[10]).to.be.eq(expected.makerAssetData);
        expect(actual[11]).to.be.eq(expected.takerAssetData);
        expect(actual[12]).to.be.eq(expected.makerFeeAssetData);
        expect(actual[13]).to.be.eq(expected.takerFeeAssetData);
    }

    describe('fillOrKillOrder', () => {
        it('works if the order is filled by exactly `takerAssetFillAmount`', async () => {
            const fillAmount = randomAmount();
            const order = randomOrder({
                // `_fillOrder()` is overridden to always return `order.takerAssetAmount` as
                // the `takerAssetFilledAmount`.
                takerAssetAmount: fillAmount,
            });
            const signature = createOrderSignature(order);
            const expectedResult = getExpectedFillResults(order, signature);
            const expectedCalls = [[ order, fillAmount, signature ]];
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.fillOrKillOrder,
                order,
                fillAmount,
                signature,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls as any);
        });

        it('reverts if the order is filled by less than `takerAssetFillAmount`', async () => {
            const fillAmount = randomAmount();
            const order = randomOrder({
                // `_fillOrder()` is overridden to always return `order.takerAssetAmount` as
                // the `takerAssetFilledAmount`.
                takerAssetAmount: fillAmount.minus(1),
            });
            const expectedError = new ExchangeRevertErrors.IncompleteFillError(
                getExpectedOrderHash(order),
            );
            const tx = testContract.fillOrKillOrder.awaitTransactionSuccessAsync(
                order,
                fillAmount,
                createOrderSignature(order),
            );
            return expect(tx).to.revertWith(expectedError);
        });

        it('reverts if the order is filled by greater than `takerAssetFillAmount`', async () => {
            const fillAmount = randomAmount();
            const order = randomOrder({
                // `_fillOrder()` is overridden to always return `order.takerAssetAmount` as
                // the `takerAssetFilledAmount`.
                takerAssetAmount: fillAmount.plus(1),
            });
            const expectedError = new ExchangeRevertErrors.IncompleteFillError(
                getExpectedOrderHash(order),
            );
            const tx = testContract.fillOrKillOrder.awaitTransactionSuccessAsync(
                order,
                fillAmount,
                createOrderSignature(order),
            );
            return expect(tx).to.revertWith(expectedError);
        });

        it('reverts if `_fillOrder()` reverts', async () => {
            const fillAmount = randomAmount();
            const order = randomOrder({
                salt: ALWAYS_FAILING_SALT,
            });
            const expectedError = ALWAYS_FAILING_SALT_REVERT_ERROR;
            const tx = testContract.fillOrKillOrder.awaitTransactionSuccessAsync(
                order,
                fillAmount,
                createOrderSignature(order),
            );
            return expect(tx).to.revertWith(expectedError);
        });
    });

    describe('fillOrderNoThrow', () => {
        it('calls `fillOrder()` and returns its result', async () => {
            const fillAmount = randomAmount();
            const order = randomOrder();
            const signature = createOrderSignature(order);
            const expectedResult = getExpectedFillResults(order, signature);
            const expectedCalls = [[ order, fillAmount, signature ]];
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.fillOrderNoThrow,
                order,
                fillAmount,
                signature,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls as any);
        });

        it('does not revert if `fillOrder()` reverts', async () => {
            const fillAmount = randomAmount();
            const order = randomOrder({
                salt: ALWAYS_FAILING_SALT,
            });
            const signature = createOrderSignature(order);
            const expectedResult = EMPTY_FILL_RESULTS;
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.fillOrderNoThrow,
                order,
                fillAmount,
                signature,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, []);
        });
    });

    describe('batchFillOrders', () => {
        it('works with no fills', async () => {
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrders,
                [],
                [],
                [],
            );
            expect(actualResult).to.deep.eq([]);
            assertFillOrderCallsFromLogs(receipt.logs, []);
        });

        it('works with one fill', async () => {
            const COUNT = 1;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            const expectedResult = _.times(COUNT, i => getExpectedFillResults(orders[i], signatures[i]));
            const expectedCalls = _.zip(orders, fillAmounts, signatures);
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrders,
                orders,
                fillAmounts,
                signatures,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls as any);
        });

        it('works with many fills', async () => {
            const COUNT = 8;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            const expectedResult = _.times(COUNT, i => getExpectedFillResults(orders[i], signatures[i]));
            const expectedCalls = _.zip(orders, fillAmounts, signatures);
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrders,
                orders,
                fillAmounts,
                signatures,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls as any);
        });

        it('works with duplicate orders', async () => {
            const COUNT = 2;
            const order = randomOrder();
            const signature = createOrderSignature(order);
            const orders = _.times(COUNT, () => order);
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount.dividedToIntegerBy(COUNT));
            const signatures = _.times(COUNT, () => signature);
            const expectedResult = _.times(COUNT, i => getExpectedFillResults(orders[i], signatures[i]));
            const expectedCalls = _.zip(orders, fillAmounts, signatures);
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrders,
                orders,
                fillAmounts,
                signatures,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls as any);
        });

        it('reverts if there are more orders than fill amounts', async () => {
            const COUNT = 8;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT - 1, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            const expectedError = new AnyRevertError(); // Just a generic revert.
            const tx = txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrders,
                orders,
                fillAmounts,
                signatures,
            );
            return expect(tx).to.revertWith(expectedError);
        });

        it('reverts if there are more orders than signatures', async () => {
            const COUNT = 8;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT - 1, i => createOrderSignature(orders[i]));
            const expectedError = new AnyRevertError(); // Just a generic revert.
            const tx = txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrders,
                orders,
                fillAmounts,
                signatures,
            );
            return expect(tx).to.revertWith(expectedError);
        });
    });

    describe('batchFillOrKillOrders', () => {
        it('works with no fills', async () => {
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrKillOrders,
                [],
                [],
                [],
            );
            expect(actualResult).to.deep.eq([]);
            assertFillOrderCallsFromLogs(receipt.logs, []);
        });

        it('works with one fill', async () => {
            const COUNT = 1;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            const expectedResult = _.times(COUNT, i => getExpectedFillResults(orders[i], signatures[i]));
            const expectedCalls = _.zip(orders, fillAmounts, signatures);
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrKillOrders,
                orders,
                fillAmounts,
                signatures,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls as any);
        });

        it('works with many fills', async () => {
            const COUNT = 8;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            const expectedResult = _.times(COUNT, i => getExpectedFillResults(orders[i], signatures[i]));
            const expectedCalls = _.zip(orders, fillAmounts, signatures);
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrKillOrders,
                orders,
                fillAmounts,
                signatures,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls as any);
        });

        it('works with duplicate orders', async () => {
            const COUNT = 2;
            const order = randomOrder();
            const signature = createOrderSignature(order);
            const orders = _.times(COUNT, () => order);
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, () => signature);
            const expectedResult = _.times(COUNT, i => getExpectedFillResults(orders[i], signatures[i]));
            const expectedCalls = _.zip(orders, fillAmounts, signatures);
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrKillOrders,
                orders,
                fillAmounts,
                signatures,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls as any);
        });

        it('reverts if any fill sells less than its takerAssetFillAmount', async () => {
            const COUNT = 8;
            const FAILING_ORDER_INDEX = 6;
            const orders = _.times(COUNT, () => randomOrder());
            const failingOrder = orders[FAILING_ORDER_INDEX];
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            // `_fillOrder()` is overridden to always return `order.takerAssetAmount` as
            // the `takerAssetFilledAmount`.
            failingOrder.takerAssetAmount = failingOrder.takerAssetAmount.minus(1);
            const expectedError = new ExchangeRevertErrors.IncompleteFillError(
                getExpectedOrderHash(failingOrder),
            );
            const tx = txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrKillOrders,
                orders,
                fillAmounts,
                signatures,
            );
            return expect(tx).to.revertWith(expectedError);
        });

        it('reverts if any fill sells more than its takerAssetFillAmount', async () => {
            const COUNT = 8;
            const FAILING_ORDER_INDEX = 6;
            const orders = _.times(COUNT, () => randomOrder());
            const failingOrder = orders[FAILING_ORDER_INDEX];
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            // `_fillOrder()` is overridden to always return `order.takerAssetAmount` as
            // the `takerAssetFilledAmount`.
            failingOrder.takerAssetAmount = failingOrder.takerAssetAmount.plus(1);
            const expectedError = new ExchangeRevertErrors.IncompleteFillError(
                getExpectedOrderHash(failingOrder),
            );
            const tx = txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrKillOrders,
                orders,
                fillAmounts,
                signatures,
            );
            return expect(tx).to.revertWith(expectedError);
        });

        it('reverts if there are more orders than fill amounts', async () => {
            const COUNT = 8;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT - 1, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            const expectedError = new AnyRevertError(); // Just a generic revert.
            const tx = txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrKillOrders,
                orders,
                fillAmounts,
                signatures,
            );
            return expect(tx).to.revertWith(expectedError);
        });

        it('reverts if there are more orders than signatures', async () => {
            const COUNT = 8;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT - 1, i => createOrderSignature(orders[i]));
            const expectedError = new AnyRevertError(); // Just a generic revert.
            const tx = txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrKillOrders,
                orders,
                fillAmounts,
                signatures,
            );
            return expect(tx).to.revertWith(expectedError);
        });
    });

    describe('marketSellOrders', () => {
        function simulateMarketSellOrders(
            orders: Order[],
            takerAssetFillAmount: BigNumber,
            signatures: string[],
        ): [FillResults, [[Order, BigNumber, string]]] {
            const fillOrderCalls = [];
            let fillResults = _.cloneDeep(EMPTY_FILL_RESULTS);
            const takerAssetData = orders[0].takerAssetData;
            for (const [ order, signature ] of _.zip(orders, signatures) as [[Order, string]]) {
                const remainingTakerAssetFillAmount = safeSub(
                    takerAssetFillAmount,
                    fillResults.takerAssetFilledAmount,
                );
                const expectedSignature = createOrderSignature(
                    {
                        ...order,
                        takerAssetData,
                    },
                );
                if (order.salt !== ALWAYS_FAILING_SALT && signature !== expectedSignature) {
                    fillOrderCalls.push([order, remainingTakerAssetFillAmount, signature]);
                    fillResults = addFillResults(fillResults, getExpectedFillResults(order, signature));
                }
                if (fillResults.takerAssetFilledAmount.gte(takerAssetFillAmount)) {
                    break;
                }
            }
            return [fillResults, fillOrderCalls as any];
        }

        it('works with one order', async () => {
            const COUNT = 1;
            const orders = _.times(COUNT, () => randomOrder());
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            const takerAssetFillAmount = _.reduce(
                orders,
                (total, o) => o.takerAssetAmount.plus(total),
                constants.ZERO_AMOUNT,
            );
            const [ expectedResult, expectedCalls ] = simulateMarketSellOrders(
                orders,
                takerAssetFillAmount,
                signatures,
            );
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.marketSellOrders,
                orders,
                takerAssetFillAmount,
                signatures,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls);
        });

        it('reverts with no orders', async () => {
            const expectedError = new AnyRevertError();
            const tx = txHelper.getResultAndReceiptAsync(
                testContract.marketSellOrders,
                [],
                constants.ZERO_AMOUNT,
                [],
            );
            return expect(tx).to.revertWith(expectedError);
        });
    });

    describe('batchFillOrdersNoThrow', () => {
        it('works with no fills', async () => {
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrdersNoThrow,
                [],
                [],
                [],
            );
            expect(actualResult).to.deep.eq([]);
            assertFillOrderCallsFromLogs(receipt.logs, []);
        });

        it('works with one fill', async () => {
            const COUNT = 1;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            const expectedResult = _.times(COUNT, i => getExpectedFillResults(orders[i], signatures[i]));
            const expectedCalls = _.zip(orders, fillAmounts, signatures);
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrdersNoThrow,
                orders,
                fillAmounts,
                signatures,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls as any);
        });

        it('works with many fills', async () => {
            const COUNT = 8;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            const expectedResult = _.times(COUNT, i => getExpectedFillResults(orders[i], signatures[i]));
            const expectedCalls = _.zip(orders, fillAmounts, signatures);
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrdersNoThrow,
                orders,
                fillAmounts,
                signatures,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls as any);
        });

        it('works with duplicate orders', async () => {
            const COUNT = 2;
            const order = randomOrder();
            const signature = createOrderSignature(order);
            const orders = _.times(COUNT, () => order);
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount.dividedBy(COUNT));
            const signatures = _.times(COUNT, () => signature);
            const expectedResult = _.times(COUNT, i => getExpectedFillResults(orders[i], signatures[i]));
            const expectedCalls = _.zip(orders, fillAmounts, signatures);
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrdersNoThrow,
                orders,
                fillAmounts,
                signatures,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls as any);
        });

        it('works if a fill fails', async () => {
            const COUNT = 8;
            const FAILING_ORDER_INDEX = 6;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            const failingOrder = orders[FAILING_ORDER_INDEX];
            failingOrder.salt = ALWAYS_FAILING_SALT;
            const expectedResult = _.times(COUNT, i => getExpectedFillResults(orders[i], signatures[i]));
            const expectedCalls = _.zip(orders, fillAmounts, signatures);
            expectedCalls.splice(FAILING_ORDER_INDEX, 1);
            const [ actualResult, receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrdersNoThrow,
                orders,
                fillAmounts,
                signatures,
            );
            expect(actualResult).to.deep.eq(expectedResult);
            assertFillOrderCallsFromLogs(receipt.logs, expectedCalls as any);
        });

        it('reverts if there are more orders than fill amounts', async () => {
            const COUNT = 8;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT - 1, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT, i => createOrderSignature(orders[i]));
            const expectedError = new AnyRevertError(); // Just a generic revert.
            const tx = txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrdersNoThrow,
                orders,
                fillAmounts,
                signatures,
            );
            return expect(tx).to.revertWith(expectedError);
        });

        it('reverts if there are more orders than signatures', async () => {
            const COUNT = 8;
            const orders = _.times(COUNT, () => randomOrder());
            const fillAmounts = _.times(COUNT, i => orders[i].takerAssetAmount);
            const signatures = _.times(COUNT - 1, i => createOrderSignature(orders[i]));
            const expectedError = new AnyRevertError(); // Just a generic revert.
            const tx = txHelper.getResultAndReceiptAsync(
                testContract.batchFillOrdersNoThrow,
                orders,
                fillAmounts,
                signatures,
            );
            return expect(tx).to.revertWith(expectedError);
        });
    });

    // Asserts that `_cancelOrder()` was called in the same order and with the same
    // arguments as given by examining receipt logs.
    function assertCancelOrderCallsFromLogs(
        logs: LogEntry[],
        calls: Order[],
    ): void {
        expect(logs.length).to.eq(calls.length);
        for (const i of _.times(calls.length)) {
            const log = logs[i] as LogWithDecodedArgs<CancelOrderCalledEventArgs>;
            const expectedOrder = calls[i];
            expect(log.event).to.eq('CancelOrderCalled');
            assertSameOrderFromEvent(log.args.order as any, expectedOrder);
        }
    }

    describe('batchCancelOrders', () => {
        it('works with no orders', async () => {
            const [ , receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchCancelOrders,
                [],
            );
            assertCancelOrderCallsFromLogs(receipt.logs, []);
        });

        it('works with many orders', async () => {
            const COUNT = 8;
            const orders = _.times(COUNT, () => randomOrder({ makerAddress: senderAddress }));
            const [ , receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchCancelOrders,
                orders,
            );
            assertCancelOrderCallsFromLogs(receipt.logs, orders);
        });

        it('works with duplicate orders', async () => {
            const COUNT = 3;
            const order = randomOrder({ makerAddress: senderAddress });
            const orders = _.times(COUNT, () => order);
            const [ , receipt ] = await txHelper.getResultAndReceiptAsync(
                testContract.batchCancelOrders,
                orders,
            );
            assertCancelOrderCallsFromLogs(receipt.logs, orders);
        });

        it('reverts if one `_cancelOrder()` reverts', async () => {
            const COUNT = 8;
            const FAILING_ORDER_INDEX = 4;
            const orders = _.times(COUNT, () => randomOrder({ makerAddress: senderAddress }));
            const failingOrder = orders[FAILING_ORDER_INDEX];
            failingOrder.salt = ALWAYS_FAILING_SALT;
            const expectedError = ALWAYS_FAILING_SALT_REVERT_ERROR;
            const tx = txHelper.getResultAndReceiptAsync(
                testContract.batchCancelOrders,
                orders,
            );
            return expect(tx).to.revertWith(expectedError);
        });
    });

    describe('getOrdersInfo', () => {
        // Computes the expected (fake) order info generated by the `TestWrapperFunctions` contract.
        function getExpectedOrderInfo(order: Order): OrderInfo {
            const MAX_ORDER_STATUS = OrderStatus.Cancelled;
            return {
                orderHash: getExpectedOrderHash(order),
                // Lower uint128 of `order.salt` is the `orderTakerAssetFilledAmount`.
                orderTakerAssetFilledAmount: order.salt.mod(new BigNumber(2).pow(128)),
                // High byte of `order.salt` is the `orderStatus`.
                orderStatus: order.salt.dividedToIntegerBy(
                    new BigNumber(2).pow(248)).toNumber() % (MAX_ORDER_STATUS + 1),
            };
        }

        it('works with no orders', async () => {
            const infos = await testContract.getOrdersInfo.callAsync([]);
            expect(infos.length).to.eq(0);
        });

        it('works with one order', async () => {
            const orders = [ randomOrder() ];
            const expectedResult = orders.map(getExpectedOrderInfo);
            const actualResult = await testContract.getOrdersInfo.callAsync(orders);
            expect(actualResult).to.deep.eq(expectedResult);
        });

        it('works with many orders', async () => {
            const NUM_ORDERS = 16;
            const orders = _.times(NUM_ORDERS, () => randomOrder());
            const expectedResult = orders.map(getExpectedOrderInfo);
            const actualResult = await testContract.getOrdersInfo.callAsync(orders);
            expect(actualResult).to.deep.eq(expectedResult);
        });

        it('works with duplicate orders', async () => {
            const NUM_UNIQUE_ORDERS = 4;
            const CLONE_COUNT = 2;
            const uniqueOrders = _.times(NUM_UNIQUE_ORDERS, () => randomOrder());
            const orders = _.flatten(_.times(CLONE_COUNT, () => uniqueOrders));
            const expectedResult = orders.map(getExpectedOrderInfo);
            const actualResult = await testContract.getOrdersInfo.callAsync(orders);
            expect(actualResult).to.deep.eq(expectedResult);
        });
    });
});
// tslint:disable-next-line: max-file-line-count
