import * as FS from "fs";
import * as Path from "path";

import {DefaultTheme} from "./DefaultTheme";
import {Renderer} from "../Renderer";
import {UrlMapping} from "../models/UrlMapping";
import {ProjectReflection} from "../../models/reflections/ProjectReflection";
import {OutputPageEvent} from "../events/OutputPageEvent";
import {NavigationItem} from "../models/NavigationItem";
import {Reflection} from "../../models/Reflection";
import {DeclarationReflection} from "../../models/reflections/DeclarationReflection";


export class MinimalTheme extends DefaultTheme
{
    /**
     * Create a new DefaultTheme instance.
     *
     * @param renderer  The renderer this theme is attached to.
     * @param basePath  The base path of this theme.
     */
    constructor(renderer:Renderer, basePath:string) {
        super(renderer, basePath);

        renderer.removePlugin('assets');
        renderer.removePlugin('javascriptIndex');
        renderer.removePlugin('navigation');
        renderer.removePlugin('toc');

        renderer.on(Renderer.EVENT_BEGIN_PAGE, this.onRendererBeginPage, this);
    }


    /**
     * Test whether the given path contains a documentation generated by this theme.
     *
     * @param path  The path of the directory that should be tested.
     * @returns     TRUE if the given path seems to be a previous output directory,
     *              otherwise FALSE.
     */
    isOutputDirectory(path:string):boolean {
        if (!FS.existsSync(Path.join(path, 'index.html'))) return false;
        return true;
    }


    /**
     * Map the models of the given project to the desired output files.
     *
     * @param project  The project whose urls should be generated.
     * @returns        A list of [[UrlMapping]] instances defining which models
     *                 should be rendered to which files.
     */
    getUrls(project:ProjectReflection):UrlMapping[] {
        var urls:UrlMapping[] = [];
        urls.push(new UrlMapping('index.html', project, 'index.hbs'));

        project.url = 'index.html';
        project.anchor = null;
        project.hasOwnDocument = true;

        project.children.forEach((child) => {
            DefaultTheme.applyAnchorUrl(child, project);
        });

        return urls;
    }


    /**
     * Triggered before a document will be rendered.
     *
     * @param page  An event object describing the current render operation.
     */
    private onRendererBeginPage(page:OutputPageEvent) {
        var model = page.model;
        if (!(model instanceof Reflection)) {
            return;
        }

        page.toc = new NavigationItem();
        MinimalTheme.buildToc(page.model, page.toc);
    }


    /**
     * Create a toc navigation item structure.
     *
     * @param model   The models whose children should be written to the toc.
     * @param parent  The parent [[Models.NavigationItem]] the toc should be appended to.
     */
    static buildToc(model:DeclarationReflection, parent:NavigationItem) {
        var children = model.children || [];
        children.forEach((child:DeclarationReflection) => {
            var item = NavigationItem.create(child, parent, true);
            MinimalTheme.buildToc(child, item);
        });
    }
}
