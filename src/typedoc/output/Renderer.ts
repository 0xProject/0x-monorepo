module TypeDoc.Output
{
    export interface IHandlebarTemplate {
        (context?: any, options?: any):string;
    }


    export class Renderer extends EventDispatcher
    {
        application:Application;

        plugins:BasePlugin[];

        theme:BaseTheme;

        ioHost:TypeScript.IIO;

        private templates:{[path:string]:IHandlebarTemplate} = {};

        static PLUGIN_CLASSES:any[] = [];


        constructor(application:Application) {
            super();
            this.application = application;
            this.ioHost  = TypeScript.IO;

            this.plugins = [];
            Renderer.PLUGIN_CLASSES.forEach((pluginClass) => {
                this.plugins.push(new pluginClass(this));
            });

            Marked.setOptions({
                highlight: (code:string) => HighlightJS.highlightAuto(code).value
            });

            Handlebars.registerHelper('compact', function(options) {
                var lines = options.fn(this).split('\n');
                for (var i = 0, c = lines.length; i < c; i++) {
                    lines[i] = lines[i].trim().replace(/&nbsp;/, ' ');
                }
                return lines.join('');
            });

            Handlebars.registerHelper('markdown', function(options) {
                return Marked(options.fn(this));
            });
        }


        setTheme(dirname:string) {
            dirname = this.ioHost.resolvePath(dirname);
            if (!this.ioHost.fileExists(dirname)) {
                throw new Error('Theme directory ´' + dirname + '´ does not exist.');
            }

            var filename = TypeScript.IOUtils.combine(dirname, 'theme.js');
            if (!this.ioHost.fileExists(filename)) {
                throw new Error('Theme theme.js ´' + filename + '´ does not exist.');
            }

            var themeClass = eval(readFile(filename));
            this.theme = new themeClass(this, dirname);
        }


        getDefaultTheme() {
            var compilerFilePath = this.ioHost.getExecutingFilePath();
            var containingDirectoryPath = this.ioHost.dirName(compilerFilePath);
            var libraryFilePath = Path.resolve(TypeScript.IOUtils.combine(TypeScript.IOUtils.combine(containingDirectoryPath, 'themes'), 'default'));

            return libraryFilePath;
        }


        getTemplate(fileName:string):IHandlebarTemplate {
            if (!this.theme) {
                throw new Error('Cannot resolve templates before theme is set.');
            }

            if (!this.templates[fileName]) {
                var absFileName = TypeScript.IOUtils.combine(this.theme.basePath, fileName);
                absFileName = this.ioHost.resolvePath(absFileName);

                if (!this.ioHost.fileExists(absFileName)) {
                    throw new Error('Cannot find template ´' + absFileName + '´.');
                }

                this.templates[fileName] = Handlebars.compile(readFile(absFileName));
            }

            return this.templates[fileName];
        }


        render(project:Models.ProjectReflection, outputDirectory:string) {
            if (!this.theme) {
                this.setTheme(this.getDefaultTheme());
            }

            if (FS.existsSync(outputDirectory)) {
                if (!this.theme.isOutputDirectory(outputDirectory)) {
                    this.application.hasErrors = true;
                    this.ioHost.printLine('Error: The output directory "' + outputDirectory + '" exists but ' +
                        'does not seem to be a documentation generated by TypeDoc.\n' +
                        'Make sure this is the right target directory, delete the folder and rerun TypeDoc.');
                    return;
                }

                try {
                    FS.rmrfSync(outputDirectory);
                } catch (error) {
                    this.ioHost.printLine('Warning: Could not empty the output directory.');
                }
            }

            if (!FS.existsSync(outputDirectory)) {
                try {
                    FS.mkdirpSync(outputDirectory);
                } catch (error) {
                    this.application.hasErrors = true;
                    this.ioHost.printLine('Error: Could not create output directory ' + outputDirectory);
                    return;
                }
            }

            var target     = new Models.RenderTarget();
            target.dirname = outputDirectory;
            target.project = project;
            target.urls    = this.theme.getUrls(project);

            this.dispatch('beginTarget', target);
            if (target.isDefaultPrevented) return;

            this.renderTarget(target);
            this.dispatch('endTarget', target);
        }


        private renderTarget(target:Models.RenderTarget) {
            target.urls.forEach((mapping:Models.UrlMapping) => {
                var output          = new Models.RenderOutput(target);
                output.project      = target.project
                output.url          = mapping.url;
                output.model        = mapping.model;
                output.templateName = mapping.template;
                output.template     = this.getTemplate(Path.join('templates', mapping.template));
                output.filename     = Path.join(target.dirname, mapping.url);

                this.dispatch('beginOutput', output);
                if (output.isDefaultPrevented || !output.template) return;

                output.contents = output.template(output);

                this.dispatch('endOutput', output);
                if (output.isDefaultPrevented) return;

                try {
                    TypeScript.IOUtils.writeFileAndFolderStructure(this.ioHost, output.filename, output.contents, true);
                } catch (error) {
                    this.ioHost.printLine('Error: Could not write ' + output.filename);
                }
            });
        }
    }
}