module TypeDoc.Output
{
    /**
     * Defines a mapping of a [[Models.Kind]] to a template file.
     *
     * Used by [[DefaultTheme]] to map reflections to output files.
     */
    export interface ITemplateMapping
    {
        /**
         * [[DeclarationReflection.kind]] this rule applies to.
         */
        kind:TypeScript.PullElementKind[];

        /**
         * Can this mapping have children or should all further reflections be rendered
         * to the defined output page?
         */
        isLeaf:boolean;

        /**
         * The name of the directory the output files should be written to.
         */
        directory:string;

        /**
         * The name of the template that should be used to render the reflection.
         */
        template:string;
    }


    /**
     * Default theme implementation of TypeDoc. If a theme does not provide a custom
     * [[BaseTheme]] implementation, this theme class will be used.
     */
    export class DefaultTheme extends BaseTheme
    {
        /**
         * Mappings of reflections kinds to templates used by this theme.
         */
        static MAPPINGS:ITemplateMapping[] = [{
            kind:      [TypeScript.PullElementKind.Class],
            isLeaf:    true,
            directory: 'classes',
            template:  'reflection.hbs'
        },{
            kind:      [TypeScript.PullElementKind.Interface],
            isLeaf:    true,
            directory: 'interfaces',
            template:  'reflection.hbs'
        },{
            kind:      [TypeScript.PullElementKind.Enum],
            isLeaf:    true,
            directory: 'enums',
            template:  'reflection.hbs'
        },{
            kind:      [TypeScript.PullElementKind.Container, TypeScript.PullElementKind.DynamicModule],
            isLeaf:    false,
            directory: 'modules',
            template:  'reflection.hbs'
        },{
            kind:      [TypeScript.PullElementKind.Script],
            isLeaf:    false,
            directory: 'scripts',
            template:  'reflection.hbs'
        }, {
            kind:      [TypeScript.PullElementKind.ObjectLiteral],
            isLeaf:    false,
            directory: 'objects',
            template:  'reflection.hbs'
        }];



        /**
         * Create a new DefaultTheme instance.
         *
         * @param renderer  The renderer this theme is attached to.
         * @param basePath  The base path of this theme.
         */
        constructor(renderer:Renderer, basePath:string) {
            super(renderer, basePath);
            renderer.on(Renderer.EVENT_BEGIN, this.onRendererBegin, this, 1024);
        }


        /**
         * Test whether the given path contains a documentation generated by this theme.
         *
         * @param path  The path of the directory that should be tested.
         * @returns     TRUE if the given path seems to be a previous output directory,
         *              otherwise FALSE.
         */
        isOutputDirectory(path:string):boolean {
            if (!FS.existsSync(Path.join(path, 'index.html'))) return false;
            if (!FS.existsSync(Path.join(path, 'assets'))) return false;
            if (!FS.existsSync(Path.join(path, 'assets', 'js', 'main.js'))) return false;
            if (!FS.existsSync(Path.join(path, 'assets', 'images', 'icons.png'))) return false;

            return true;
        }


        /**
         * Map the models of the given project to the desired output files.
         *
         * @param project  The project whose urls should be generated.
         * @returns        A list of [[UrlMapping]] instances defining which models
         *                 should be rendered to which files.
         */
        getUrls(project:Models.ProjectReflection):Models.UrlMapping[] {
            var urls = [];

            project.url = 'globals.html';
            urls.push(new Models.UrlMapping('globals.html', project, 'reflection.hbs'));
            urls.push(new Models.UrlMapping('index.html',   project, 'index.hbs'));

            project.children.forEach((child) => {
                DefaultTheme.buildUrls(child, urls);
            });

            return urls;
        }


        /**
         * Create a navigation structure for the given project.
         *
         * @param project  The project whose navigation should be generated.
         * @returns        The root navigation item.
         */
        getNavigation(project:Models.ProjectReflection):Models.NavigationItem {
            var root = new Models.NavigationItem('Index', 'index.html');
            new Models.NavigationItem('<em>Globals</em>', 'globals.html', root);

            var modules = project.getReflectionsByKind(Models.Kind.SomeContainer);
            modules.sort((a:Models.DeclarationReflection, b:Models.DeclarationReflection) => {
                return a.getFullName() < b.getFullName() ? -1 : 1;
            });

            modules.forEach((container) => {
                DefaultTheme.buildNavigation(container, root);
            });

            return root;
        }


        /**
         * Triggered before the renderer starts rendering a project.
         *
         * @param event  An event object describing the current render operation.
         */
        private onRendererBegin(event:OutputEvent) {
            if (event.project.groups) {
                event.project.groups.forEach(DefaultTheme.applyGroupClasses);
            }

            event.project.reflections.forEach((reflection) => {
                DefaultTheme.applyReflectionClasses(reflection);

                if (reflection.groups) {
                    reflection.groups.forEach(DefaultTheme.applyGroupClasses);
                }
            });
        }


        /**
         * Return a url for the given reflection.
         *
         * @param reflection  The reflection the url should be generated for.
         * @param relative    The parent reflection the url generation should stop on.
         * @param separator   The separator used to generate the url.
         * @returns           The generated url.
         */
        static getUrl(reflection:Models.BaseReflection, relative?:Models.BaseReflection, separator:string = '.'):string {
            var url = reflection.getAlias();

            if (reflection.parent && reflection.parent != relative &&
                !(reflection.parent instanceof Models.ProjectReflection))
                url = DefaultTheme.getUrl(reflection.parent, relative, separator) + separator + url;

            return url;
        }


        /**
         * Return the template mapping fore the given reflection.
         *
         * @param reflection  The reflection whose mapping should be resolved.
         * @returns           The found mapping or NULL if no mapping could be found.
         */
        static getMapping(reflection:Models.DeclarationReflection):ITemplateMapping {
            for (var i = 0, c = DefaultTheme.MAPPINGS.length; i < c; i++) {
                var mapping = DefaultTheme.MAPPINGS[i];
                if (reflection.kindOf(mapping.kind)) {
                    return mapping;
                }
            }

            return null;
        }


        /**
         * Build the navigation nodes for the given reflection.
         *
         * @param reflection  The reflection whose navigation node should be created.
         * @param parent      The parent navigation node.
         */
        static buildNavigation(reflection:Models.DeclarationReflection, parent:Models.NavigationItem) {
            var name, isPrimary;
            if (parent.parent) {
                name      = reflection.name;
                isPrimary = false;
            } else {
                name      = reflection.getFullName();
                isPrimary = true;
            }

            var item        = new Models.NavigationItem(name, reflection.url, parent);
            item.isPrimary  = isPrimary;
            item.cssClasses = reflection.cssClasses;

            reflection.children.forEach((child) => {
                if (child.kindOf(Models.Kind.SomeContainer)) return;
                DefaultTheme.buildNavigation(child, item);
            });
        }


        /**
         * Build the url for the the given reflection and all of its children.
         *
         * @param reflection  The reflection the url should be created for.
         * @param urls        The array the url should be appended to.
         * @returns           The altered urls array.
         */
        static buildUrls(reflection:Models.DeclarationReflection, urls:Models.UrlMapping[]):Models.UrlMapping[] {
            var mapping = DefaultTheme.getMapping(reflection);
            if (mapping) {
                var url = Path.join(mapping.directory, DefaultTheme.getUrl(reflection) + '.html');
                urls.push(new Models.UrlMapping(url, reflection, mapping.template));

                reflection.url            = url;
                reflection.anchor         = null;
                reflection.hasOwnDocument = true;

                reflection.children.forEach((child) => {
                    if (mapping.isLeaf) {
                        DefaultTheme.applyAnchorUrl(child, reflection);
                    } else {
                        DefaultTheme.buildUrls(child, urls);
                    }
                });
            } else {
                DefaultTheme.applyAnchorUrl(reflection, reflection.parent);
            }

            return urls;
        }


        /**
         * Generate an anchor url for the given reflection and all of its children.
         *
         * @param reflection  The reflection an anchor url should be created for.
         * @param container   The nearest reflection having an own document.
         */
        static applyAnchorUrl(reflection:Models.DeclarationReflection, container:Models.BaseReflection) {
            var anchor = DefaultTheme.getUrl(reflection, container, '.');
            if (reflection.isStatic) {
                anchor = 'static-' + anchor;
            }

            reflection.url            = container.url + '#' + anchor;
            reflection.anchor         = anchor;
            reflection.hasOwnDocument = false;

            reflection.children.forEach((child) => {
                if (!child.kindOf(Models.Kind.Parameter)) {
                    DefaultTheme.applyAnchorUrl(child, container);
                }
            });
        }

        
        /**
         * Generate the css classes for the given reflection and apply them to the
         * [[DeclarationReflection.cssClasses]] property.
         *
         * @param reflection  The reflection whose cssClasses property should be generated.
         */
        static applyReflectionClasses(reflection:Models.DeclarationReflection) {
            var classes = [];
            var kind    = Models.Kind[reflection.kind];
            classes.push(DefaultTheme.toStyleClass('tsd-kind-' + kind));

            if (reflection.parent && reflection.parent instanceof Models.DeclarationReflection) {
                kind = Models.Kind[(<Models.DeclarationReflection>reflection.parent).kind];
                classes.push(DefaultTheme.toStyleClass('tsd-parent-kind-'+ kind));
            }

            if (reflection.overwrites)    classes.push('tsd-is-overwrite');
            if (reflection.inheritedFrom) classes.push('tsd-is-inherited');
            if (reflection.isPrivate)     classes.push('tsd-is-private');
            if (reflection.isStatic)      classes.push('tsd-is-static');
            if (reflection.isExternal)    classes.push('tsd-is-external');
            if (!reflection.isExported)   classes.push('tsd-is-not-exported');

            reflection.cssClasses = classes.join(' ');
        }


        /**
         * Generate the css classes for the given reflection group and apply them to the
         * [[ReflectionGroup.cssClasses]] property.
         *
         * @param group  The reflection group whose cssClasses property should be generated.
         */
        static applyGroupClasses(group:Models.ReflectionGroup) {
            var classes = [];
            if (group.allChildrenAreInherited)  classes.push('tsd-is-inherited');
            if (group.allChildrenArePrivate)    classes.push('tsd-is-private');
            if (group.allChildrenAreExternal)   classes.push('tsd-is-external');
            if (!group.someChildrenAreExported) classes.push('tsd-is-not-exported');

            group.cssClasses = classes.join(' ');
        }


        /**
         * Transform a space separated string into a string suitable to be used as a
         * css class, e.g. "constructor method" > "Constructor-method".
         */
        static toStyleClass(str:string) {
            return str.replace(/(\w)([A-Z])/g, (m, m1, m2) => m1 + '-' + m2).toLowerCase();
        }
    }
}