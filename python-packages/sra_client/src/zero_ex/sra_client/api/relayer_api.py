# coding: utf-8


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from zero_ex.sra_client.api_client import ApiClient
from zero_ex.sra_client.configuration import Configuration
from zero_ex.sra_client.models.relayer_api_order_config_payload_schema import (
    RelayerApiOrderConfigPayloadSchema,
)


class RelayerApi(object):
    """API for SRA compliant 0x relayers."""

    # NOTE: This class is auto generated by OpenAPI Generator
    # Ref: https://openapi-generator.tech

    # Do not edit the class manually.

    def __init__(self, url: str):
        config = Configuration()
        config.host = url
        self.api_client = ApiClient(config)

    def get_asset_pairs(self, **kwargs):
        """get_asset_pairs

        Retrieves a list of available asset pairs and the information
        required to trade them (in any order). Setting only `assetDataA` or
        `assetDataB` returns pairs filtered by that asset only.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.get_asset_pairs(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param str asset_data_a: The assetData value for the first asset in the pair.
        :param str asset_data_b: The assetData value for the second asset in the pair.
        :param int page: The number of the page to request in the collection.
        :param int per_page: The number of records to return per page.

        :return: :class:`RelayerApiAssetDataPairsResponseSchema`.
            If the method is called asynchronously returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_asset_pairs_with_http_info(**kwargs)
        else:
            (data) = self.get_asset_pairs_with_http_info(**kwargs)
            return data

    def get_asset_pairs_with_http_info(self, **kwargs):
        """get_asset_pairs

        Retrieves a list of available asset pairs and the information
        required to trade them (in any order). Setting only `assetDataA` or
        `assetDataB` returns pairs filtered by that asset only.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.get_asset_pairs_with_http_info(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param str asset_data_a: The assetData value for the first asset in the pair.
        :param str asset_data_b: The assetData value for the second asset in the pair.
        :param int page: The number of the page to request in the collection.
        :param int per_page: The number of records to return per page.

        :return: A tuple consisting of a
            :class:`RelayerApiAssetDataPairsResponseSchema`, an HTTP status
            code integer, and a collection of HTTP headers.  If the method is
            called asynchronously returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            "asset_data_a",
            "asset_data_b",
            "page",
            "per_page",
        ]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_asset_pairs" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "asset_data_a" in local_var_params:
            query_params.append(
                ("assetDataA", local_var_params["asset_data_a"])
            )
        if "asset_data_b" in local_var_params:
            query_params.append(
                ("assetDataB", local_var_params["asset_data_b"])
            )
        if "page" in local_var_params:
            query_params.append(("page", local_var_params["page"]))
        if "per_page" in local_var_params:
            query_params.append(("perPage", local_var_params["per_page"]))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(
            "/v3/asset_pairs",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="RelayerApiAssetDataPairsResponseSchema",
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_fee_recipients(self, **kwargs):
        """get_fee_recipients

        Retrieves a collection of all fee recipient addresses for a relayer.
        This endpoint should be paginated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.get_fee_recipients(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param int page: The number of the page to request in the collection.
        :param int per_page: The number of records to return per page.

        :return: :class:`RelayerApiFeeRecipientsResponseSchema`.
            If the method is called asynchronously, returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_fee_recipients_with_http_info(**kwargs)
        else:
            (data) = self.get_fee_recipients_with_http_info(**kwargs)
            return data

    def get_fee_recipients_with_http_info(self, **kwargs):
        """get_fee_recipients

        Retrieves a collection of all fee recipient addresses for a relayer.
        This endpoint should be paginated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.get_fee_recipients_with_http_info(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param int page: The number of the page to request in the collection.
        :param int per_page: The number of records to return per page.

        :return: A tuple consisting of a
            :class:`RelayerApiFeeRecipientsResponseSchema`, an HTTP status
            code integer, and a collection of HTTP headers.  If the method is
            called asynchronously returns the request thread.
        """

        local_var_params = locals()

        all_params = ["page", "per_page"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fee_recipients" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "page" in local_var_params:
            query_params.append(("page", local_var_params["page"]))
        if "per_page" in local_var_params:
            query_params.append(("perPage", local_var_params["per_page"]))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(
            "/v3/fee_recipients",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="RelayerApiFeeRecipientsResponseSchema",
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_order(self, order_hash, **kwargs):
        """get_order

        Retrieves the 0x order with meta info that is associated with the hash.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.get_order(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param str order_hash: The hash of the desired 0x order. (required)

        :return: :class:`RelayerApiOrderSchema`.
            If the method is called asynchronously, returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_order_with_http_info(order_hash, **kwargs)
        else:
            (data) = self.get_order_with_http_info(order_hash, **kwargs)
            return data

    def get_order_with_http_info(self, order_hash, **kwargs):
        """get_order

        Retrieves the 0x order with meta info that is associated with the hash.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.get_order_with_http_info(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param str order_hash: The hash of the desired 0x order. (required)

        :return: A tuple consisting of a
            :class:`RelayerApiOrderSchema`, an HTTP status code integer, and a
            collection of HTTP headers.  If the method is called
            asynchronously returns the request thread.
        """

        local_var_params = locals()

        all_params = ["order_hash"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_order" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'order_hash' is set
        if (
            "order_hash" not in local_var_params
            or local_var_params["order_hash"] is None
        ):
            raise ValueError(
                "Missing the required parameter `order_hash` when calling `get_order`"
            )

        collection_formats = {}

        path_params = {}
        if "order_hash" in local_var_params:
            path_params["orderHash"] = local_var_params["order_hash"]

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(
            "/v3/order/{orderHash}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="RelayerApiOrderSchema",
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_order_config(self, **kwargs):
        """get_order_config

        Relayers have full discretion over the orders that they are willing
        to host on their orderbooks (e.g what fees they charge, etc...). In
        order for traders to discover their requirements programmatically,
        they can send an incomplete order to this endpoint and receive the
        missing fields, specifc to that order. This gives relayers a large
        amount of flexibility to tailor fees to unique traders, trading pairs
        and volume amounts. Submit a partial order and receive information
        required to complete the order: `senderAddress`,
        `feeRecipientAddress`, `makerFee`, `takerFee`.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.get_order_config(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param relayer_api_order_config_payload_schema: instance of
            :class:`RelayerApiOrderConfigPayloadSchema`. The fields of a 0x
            order the relayer may want to decide what configuration to send
            back.

        :return: :class:`RelayerApiOrderConfigResponseSchema`.
            If the method is called asynchronously returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_order_config_with_http_info(**kwargs)
        else:
            (data) = self.get_order_config_with_http_info(**kwargs)
            return data

    def get_order_config_with_http_info(self, **kwargs):
        """get_order_config

        Relayers have full discretion over the orders that they are willing
        to host on their orderbooks (e.g what fees they charge, etc...). In
        order for traders to discover their requirements programmatically,
        they can send an incomplete order to this endpoint and receive the
        missing fields, specifc to that order. This gives relayers a large
        amount of flexibility to tailor fees to unique traders, trading pairs
        and volume amounts. Submit a partial order and receive information
        required to complete the order: `senderAddress`,
        `feeRecipientAddress`, `makerFee`, `takerFee`.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.get_order_config_with_http_info(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param relayer_api_order_config_payload_schema: instance of
            :class: `RelayerApiOrderConfigPayloadSchema`. The fields of a 0x
            order the relayer may want to decide what configuration to send
            back.

        :return: A tuple consisting of a
            :class:`RelayerApiOrderConfigResponseSchema`, an HTTP status code
            integer, and a collection of HTTP headers.  If the method is
            called asynchronously returns the request thread.
        """

        local_var_params = locals()

        all_params = ["relayer_api_order_config_payload_schema"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_order_config" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "relayer_api_order_config_payload_schema" in local_var_params:
            body_params = local_var_params[
                "relayer_api_order_config_payload_schema"
            ]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(["application/json"])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(
            "/v3/order_config",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="RelayerApiOrderConfigResponseSchema",
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_orderbook(self, base_asset_data, quote_asset_data, **kwargs):
        """get_orderbook

        Retrieves the orderbook for a given asset pair. This endpoint should
        be paginated. Bids will be sorted in
        descending order by price, and asks will be sorted in ascending order
        by price. Within the price sorted orders, the orders are further
        sorted by **taker fee price** which is defined as the **takerFee**
        divided by **takerTokenAmount**. After **taker fee price**, orders are
        to be sorted by expiration in ascending order. The way pagination
        works for this endpoint is that the **page** and **perPage** query
        params apply to both `bids` and `asks` collections, and if `page` *
        `perPage` = `total` for a certain collection, the `records` for that
        collection should just be empty.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.get_orderbook(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param str base_asset_data: assetData (makerAssetData or
            takerAssetData) designated as the base currency in the
            `currency pair calculation
            <https://en.wikipedia.org/wiki/Currency_pair>`__
            of price. (required)
        :param str quote_asset_data: assetData (makerAssetData or
            takerAssetData) designated as the quote currency in the currency
            pair calculation of price. (required)
        :param int page: The number of the page to request in the collection.
        :param int per_page: The number of records to return per page.

        :return: :class:`RelayerApiOrderbookResponseSchema`.
            If the method is called asynchronously, returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_orderbook_with_http_info(
                base_asset_data, quote_asset_data, **kwargs
            )
        else:
            (data) = self.get_orderbook_with_http_info(
                base_asset_data, quote_asset_data, **kwargs
            )
            return data

    def get_orderbook_with_http_info(
        self, base_asset_data, quote_asset_data, **kwargs
    ):
        """get_orderbook

        Retrieves the orderbook for a given asset pair. This endpoint should
        be paginated. Bids will be sorted in
        descending order by price, and asks will be sorted in ascending order
        by price. Within the price sorted orders, the orders are further
        sorted by **taker fee price** which is defined as the **takerFee**
        divided by **takerTokenAmount**. After **taker fee price**, orders are
        to be sorted by expiration in ascending order. The way pagination
        works for this endpoint is that the **page** and **perPage** query
        params apply to both `bids` and `asks` collections, and if `page` *
        `perPage` = `total` for a certain collection, the `records` for that
        collection should just be empty.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.get_orderbook_with_http_info(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param str base_asset_data: assetData (makerAssetData or
            takerAssetData) designated as the base currency in the
            `currency pair calculation
            <https://en.wikipedia.org/wiki/Currency_pair>`__
            of price. (required)
        :param str quote_asset_data: assetData (makerAssetData or
            takerAssetData) designated as the quote currency in the currency
            pair calculation of price. (required)
        :param int page: The number of the page to request in the collection.
        :param int per_page: The number of records to return per page.

        :return: A tuple consisting of a
            :class:`RelayerApiOrderbookResponseSchema`, an HTTP status code
            integer, and a collection of HTTP headers.  If the method is
            called asynchronously returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            "base_asset_data",
            "quote_asset_data",
            "page",
            "per_page",
        ]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_orderbook" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'base_asset_data' is set
        if (
            "base_asset_data" not in local_var_params
            or local_var_params["base_asset_data"] is None
        ):
            raise ValueError(
                "Missing the required parameter `base_asset_data`"
                "when calling `get_orderbook`"
            )
        # verify the required parameter 'quote_asset_data' is set
        if (
            "quote_asset_data" not in local_var_params
            or local_var_params["quote_asset_data"] is None
        ):
            raise ValueError(
                "Missing the required parameter `quote_asset_data`"
                " when calling `get_orderbook`"
            )

        collection_formats = {}

        path_params = {}

        query_params = []
        if "base_asset_data" in local_var_params:
            query_params.append(
                ("baseAssetData", local_var_params["base_asset_data"])
            )
        if "quote_asset_data" in local_var_params:
            query_params.append(
                ("quoteAssetData", local_var_params["quote_asset_data"])
            )
        if "page" in local_var_params:
            query_params.append(("page", local_var_params["page"]))
        if "per_page" in local_var_params:
            query_params.append(("perPage", local_var_params["per_page"]))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(
            "/v3/orderbook",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="RelayerApiOrderbookResponseSchema",
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_orders(self, **kwargs):
        """get_orders

        Retrieves a list of orders given query parameters. This endpoint
        should be paginated. For querying an entire
        orderbook snapshot, the orderbook endpoint
        is recommended. If both makerAssetData and takerAssetData are
        specified, returned orders will be sorted by price determined by
        (takerTokenAmount/makerTokenAmount) in ascending order. By default,
        orders returned by this endpoint are unsorted.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.get_orders(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param str maker_asset_proxy_id: The maker
            `asset proxy id
            <https://0x.org/docs/tools/0x.js#enumeration-assetproxyid>`__
            (example: "0xf47261b0" for ERC20, "0x02571792" for ERC721).
        :param str taker_asset_proxy_id: The taker asset
            `asset proxy id
            <https://0x.org/docs/tools/0x.js#enumeration-assetproxyid>`__
            (example: "0xf47261b0" for ERC20, "0x02571792" for ERC721).
        :param str maker_asset_address: The contract address for the maker asset.
        :param str taker_asset_address: The contract address for the taker asset.
        :param str exchange_address: Contract address for the exchange
            contract.
        :param str sender_address: Same as senderAddress in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str maker_asset_data: Same as makerAssetData in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str taker_asset_data: Same as takerAssetData in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str trader_asset_data: Same as traderAssetData in the [0x
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str maker_address: Same as makerAddress in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str taker_address: Same as takerAddress in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str trader_address: Same as traderAddress in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str fee_recipient_address: Same as feeRecipientAddress in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param int page: The number of the page to request in the collection.
        :param int per_page: The number of records to return per page.

        :return: :class:`RelayerApiOrdersResponseSchema`.
            If the method is called asynchronously, returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_orders_with_http_info(**kwargs)
        else:
            (data) = self.get_orders_with_http_info(**kwargs)
            return data

    def get_orders_with_http_info(self, **kwargs):
        """get_orders

        Retrieves a list of orders given query parameters. This endpoint
        should be paginated. For querying an entire
        orderbook snapshot, the orderbook endpoint
        is recommended. If both makerAssetData and takerAssetData are
        specified, returned orders will be sorted by price determined by
        (takerTokenAmount/makerTokenAmount) in ascending order. By default,
        orders returned by this endpoint are unsorted.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.get_orders_with_http_info(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param str maker_asset_proxy_id: The maker
            `asset proxy id
            <https://0x.org/docs/tools/0x.js#enumeration-assetproxyid>`__
            (example: "0xf47261b0" for ERC20, "0x02571792" for ERC721).
        :param str taker_asset_proxy_id: The taker asset
            `asset proxy id
            <https://0x.org/docs/tools/0x.js#enumeration-assetproxyid>`__
            (example: "0xf47261b0" for ERC20, "0x02571792" for ERC721).
        :param str maker_asset_address: The contract address for the maker asset.
        :param str taker_asset_address: The contract address for the taker asset.
        :param str exchange_address: Same as exchangeAddress in the [0x
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str sender_address: Same as senderAddress in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str maker_asset_data: Same as makerAssetData in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str taker_asset_data: Same as takerAssetData in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str trader_asset_data: Same as traderAssetData in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str maker_address: Same as makerAddress in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str taker_address: Same as takerAddress in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str trader_address: Same as traderAddress in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param str fee_recipient_address: Same as feeRecipientAddress in the
            `0x Protocol v3 Specification
            <https://github.com/0xProject/0x-protocol-specification/blob/
            master/v3/v3-specification.md#order-message-format>`__
        :param int page: The number of the page to request in the collection.
        :param int per_page: The number of records to return per page.

        :return: A tuple consisting of a
            :class:`RelayerApiOrdersResponseSchema`, an HTTP status code
            integer, and a collection of HTTP headers.  If the method is
            called asynchronously returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            "maker_asset_proxy_id",
            "taker_asset_proxy_id",
            "maker_asset_address",
            "taker_asset_address",
            "exchange_address",
            "sender_address",
            "maker_asset_data",
            "taker_asset_data",
            "trader_asset_data",
            "maker_address",
            "taker_address",
            "trader_address",
            "fee_recipient_address",
            "page",
            "per_page",
        ]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_orders" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "maker_asset_proxy_id" in local_var_params:
            query_params.append(
                ("makerAssetProxyId", local_var_params["maker_asset_proxy_id"])
            )
        if "taker_asset_proxy_id" in local_var_params:
            query_params.append(
                ("takerAssetProxyId", local_var_params["taker_asset_proxy_id"])
            )
        if "maker_asset_address" in local_var_params:
            query_params.append(
                ("makerAssetAddress", local_var_params["maker_asset_address"])
            )
        if "taker_asset_address" in local_var_params:
            query_params.append(
                ("takerAssetAddress", local_var_params["taker_asset_address"])
            )
        if "exchange_address" in local_var_params:
            query_params.append(
                ("exchangeAddress", local_var_params["exchange_address"])
            )
        if "sender_address" in local_var_params:
            query_params.append(
                ("senderAddress", local_var_params["sender_address"])
            )
        if "maker_asset_data" in local_var_params:
            query_params.append(
                ("makerAssetData", local_var_params["maker_asset_data"])
            )
        if "taker_asset_data" in local_var_params:
            query_params.append(
                ("takerAssetData", local_var_params["taker_asset_data"])
            )
        if "trader_asset_data" in local_var_params:
            query_params.append(
                ("traderAssetData", local_var_params["trader_asset_data"])
            )
        if "maker_address" in local_var_params:
            query_params.append(
                ("makerAddress", local_var_params["maker_address"])
            )
        if "taker_address" in local_var_params:
            query_params.append(
                ("takerAddress", local_var_params["taker_address"])
            )
        if "trader_address" in local_var_params:
            query_params.append(
                ("traderAddress", local_var_params["trader_address"])
            )
        if "fee_recipient_address" in local_var_params:
            query_params.append(
                (
                    "feeRecipientAddress",
                    local_var_params["fee_recipient_address"],
                )
            )
        if "page" in local_var_params:
            query_params.append(("page", local_var_params["page"]))
        if "per_page" in local_var_params:
            query_params.append(("perPage", local_var_params["per_page"]))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(
            "/v3/orders",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="RelayerApiOrdersResponseSchema",
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_order(self, **kwargs):
        """post_order

        Submit a signed order to the relayer.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.post_order(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param signed_order_schema: Instance of :class:`SignedOrderSchema`.
            A valid signed 0x order based on the schema.

        :return: None.
            If the method is called asynchronously, returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_order_with_http_info(**kwargs)
        else:
            (data) = self.post_order_with_http_info(**kwargs)
            return data

    def post_order_with_http_info(self, **kwargs):
        """post_order

        Submit a signed order to the relayer.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass `async_req` = **True**

        >>> thread = api.post_order_with_http_info(async_req=True) # doctest: +SKIP
        >>> result = thread.get() # doctest: +SKIP

        :param bool async_req: Whether request should be asynchronous.
        :param signed_order_schema: Instance of :class:`SignedOrderSchema`
            A valid signed 0x order based on the schema.

        :return: A tuple consisting of the response data (always empty for this
            method), an HTTP status code integer, and a collection of HTTP
            headers.  If the method is called asynchronously returns the
            request thread.
        """

        local_var_params = locals()

        all_params = ["signed_order_schema"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        for key, val in six.iteritems(local_var_params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_order" % key
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "signed_order_schema" in local_var_params:
            body_params = local_var_params["signed_order_schema"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(["application/json"])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(
            "/v3/order",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get(
                "_return_http_data_only"
            ),
            _preload_content=local_var_params.get("_preload_content", True),
            _request_timeout=local_var_params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
